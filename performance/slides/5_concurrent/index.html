<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Performance: Concurrency</title><meta charset="UTF-8"></meta><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.io/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="hovercraft.css" media="screen,projection"></link><script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        showProcessingMessages: false,
        messageStyle: "none",
        TeX : { extensions : ['color.js'] }
      });
    </script></head><body class="impress-not-supported"><div id="impress-help"></div><div id="impress" data-transition-duration="1000"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="agenda">Agenda</h1><ul><li>Intro</li><li>Parallel primitives</li><li>Parallel problems</li><li>Parallel patterns</li><li>A hard problem</li></ul><div class="notes"><p>Examples in this workshop will be in Go. Reason: It's rather simple there. C
requires pthreads, which is a bit of an arcane library. Python has threads,
but they suck greatly (GIL). Other languages like Javascript are single threaded
by nature (well, there are web workers, but that's embarassing). Parallel
programming in bash would be fun, but you might not share my sense of humor.</p></div><img src="images/thread.jpg" width="40%"></img></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="parallel-programming">Parallel programming</h1><p><em>&#xBB;The art of distributing work to maximize
the use of resources with minimal overhead.&#xAB;</em></p><p class="small-text">(while not shooting yourself in the knee by getting confused with the mindboggling behemoth you created)</p><div class="notes"><p>It really is an art, since there are no easy guidelines.</p><p>There are two ways to be comfortable writing parallel code:</p><ul><li>Being very experienced and having made a lot of mistakes.</li><li>Being fearless and not be aware of the possible problems.</li></ul></div></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="rule-of-thumb">Rule of thumb &#x1F44D;</h1><div class="line-block"><br></br></div><p class="big-text"><strong>Don't.</strong> &#xB9;</p><p class="small-text">&#xB9; Unless you really, really need the performance and you proved this by benchmarks.</p><div class="notes"><p>Just to repeat: Concurrency hurts readability, will almost inevitably cause bugs
and eat your hamster. Proceed at your own risk.</p></div></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><p class="quote">If you write the code as cleverly as possible, you are,
by definition, not smart enough to debug it.</p><div class="line-block">- <strong>Brian Kernighan</strong><br></br></div><div class="notes"><p>Especially true for parallel programming as our brain is really not build
to think this way. So our mind's horizon is never far away when doing
parallel programming.</p></div></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="concurrent-vs-parallel-1">Concurrent vs Parallel #1</h1><p>Please define it.</p><div class="notes"><p>Concurrent = execution might be interrupted at an time.
Parallel = several instructions get executed at the same time.</p></div></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><h1 id="concurrent-vs-parallel-2">Concurrent vs Parallel #2</h1><img src="images/event-loop-concurrent.jpg"></img></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><h1 id="what-are-processes">What are processes?</h1><ul><li>Processes are a lightweight way to schedule work over all available cpu cores.</li><li>Processes get started by <tt>fork()</tt> (except PID 1)</li><li>Processes focus on memory isolation - memory can only be shared via IPC (unix sockets, pipes, shared memory, network...)</li><li>Processes have their own ID (PID)</li></ul></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="11200" data-y="0" data-z="0"><h1 id="what-are-threads">What are threads?</h1><ul><li>Threads are lightweight processes (again?)</li><li>Threads get started by <tt>pthread_create()</tt> (except first thread, which exists implicitly)</li><li>Threads share the heap of the process but have each their own stack</li><li>Threads have their own ID (TID)</li></ul><div class="notes"><p>Threads are scheduled like processes by the kernel. No real difference is made between
processes and threads in that regard.</p></div></div><div class="step step-level-1" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12800" data-y="0" data-z="0"><h1 id="what-are-coroutines">What are coroutines?</h1><ul><li>Coroutines are lightweight threads (oh come on)</li><li>Coroutines are implemented completely in user space using a scheduler</li><li>Every detail depends on the individual programming languages' implementation</li><li>Goroutines are one example of a coroutine implementation. Fibers are another often used term.</li><li>Not a kernel concept, kernel scheduler does not care.</li></ul><div class="notes"><p>Good example of software evolution. Old concepts are never cleaned up. Just new concepts
get added that enhance (in the best case) the old concepts. I call this toilet paper development:
If it stinks, put another layer over it.</p><p>In case of Go, there is a scheduler that is started inside every program written in Go. It starts
a number of threads (see GOMAXPROCS) and schedules the set of go routines over the set of threads.</p></div></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="14400" data-y="0" data-z="0"><h1 id="summary">Summary</h1><img src="images/time_sharing_threads.png"></img></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="16000" data-y="0" data-z="0"><h1 id="a-word-of-warning">A word of warning &#x26A0;</h1><img src="images/epoll_vs_othersz.png" width="120%"></img><div class="notes"><p>Benchmark of a webserver handling dummy requests:</p><ul><li>forking: Spawn a new process per request.</li><li>preforking: Use a pool of worker process.</li><li>threaded: Spawn a new thread per request.</li><li>prethreaded: Use a pool of woerk threads.</li><li>poll: Single threaded using the poll() syscall.</li><li>epoll: Single threaded using the epoll() syscall.</li></ul><p>"Concurrency" is the number of requests per sec thrown
at the server, y axis is the actual handled requests.</p><p>Just throwing multithreading on a problem makes it complex,
but does not necessarily solve it.</p><p>Source: <a href="https://unixism.net/loti/async_intro.html">https://unixism.net/loti/async_intro.html</a></p><p>More details on the individual benchmarks:</p><p><a href="https://unixism.net/2019/04/linux-applications-performance-introduction">https://unixism.net/2019/04/linux-applications-performance-introduction</a></p><p>Most of the time, when used in the right dose, multithreaded programming
can easily speed up things. That's why this part of the workshop focuses more
on the safe use of parallel programming instead of squeezing every last bit
of performance out of parallel programming. Multiple threads are basically
a single optimization and deserve their own chapter therefore.</p><p>The contents in this part of the workshop are best applied with the understanding
of the CPU and Memory chapters.</p></div></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="17600" data-y="0" data-z="0"><h1 id="preemption">Preemption</h1><img src="images/preemption.png" width="100%"></img><div class="notes"><p>Linux' scheduling is preemptive. This means that a high priority task
can be worked on by interrupting a task with lower priority.</p><p>Preemption points: The scheduler can interrupt a process at pretty much
any point in time. Normally this happens in any of those cases:</p><ul><li>Process used up their time share.</li><li>Process made a syscall. While execution happens in kernel, other
cores can work up on other tasks (especially for things like recv(),
or read() where the kernel also just waits on hardware)</li><li>When the process calls sched_yield() (or sleep())</li></ul></div></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="19200" data-y="0" data-z="0"><h1 id="synchronization">Synchronization</h1><img src="images/thread_shared_state.png" width="100%"></img><div class="notes"><p>As with humans that work on a project in paralle, parallel jobs
need to synchronize to be useful. There is a big toolbox to do so.</p><p>If you use processes you obviously need to synchronize too sometimes.
Potential ways can be to use filesystem locks or mlock() on shared memory.</p><p>Failure to synchronize leads to race conditions and other bugs that are
really not fun to find. Debuggers won't work and prints might change
timings so deadlocks or race conditions might not always occur.</p></div></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="20800" data-y="0" data-z="0"><h1 id="critical-section">Critical Section</h1><pre class="highlight code go"><span class="kd">var</span><span class="w"> </span><span class="nx">count</span><span class="w"> </span><span class="kt">int</span><span class="w">

</span><span class="kd">func</span><span class="w"> </span><span class="nx">inc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="c1">// critical section start</span><span class="w">
    </span><span class="nx">count</span><span class="o">++</span><span class="w">
    </span><span class="c1">// critical section end</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">go</span><span class="w"> </span><span class="nx">inc</span><span class="p">()</span><span class="w">
    </span><span class="k">go</span><span class="w"> </span><span class="nx">inc</span><span class="p">()</span><span class="w">
</span><span class="p">}</span></pre><div class="notes"><p>Keep critical sections as small as possible - for performance &amp; sanity.</p><p>Question for you: What synchronisation primitives do you know?</p><p>If you don't mention "sleep" then you're a little dishonest ;-)</p></div></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="22400" data-y="0" data-z="0"><h1 id="parallel-code-smell-1">Parallel code smell #1 &#x1F443;</h1><p class="quote">Never start a goroutine/thread/process without knowing how it will stop.</p><div class="line-block">- <strong>Dave Cheney</strong><br></br></div><div class="notes"><p>The previous slide had a race condition: The program might have exited before
the go routine do anything. In general: You should think about how your goroutines
are terminated.</p><p>Why? Similar to memory leaks, the phenomen of goroutine leaks exist. Most of them
come from place where people think "Ah, I don't need to close that go routine".</p><p>More background:
<a href="https://dave.cheney.net/2016/12/22/never-start-a-goroutine-without-knowing-how-it-will-stop">https://dave.cheney.net/2016/12/22/never-start-a-goroutine-without-knowing-how-it-will-stop</a></p></div></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="24000" data-y="0" data-z="0"><h1 id="primitive-sleep">Primitive: <tt>sleep()</tt></h1><p>Just kidding. <strong>Don't!</strong></p><div class="notes"><p>In all seriousness: there are some edge cases where sleep() is the only
way to reach some sort of sync state. Especially when we have to wait
on some external process that we cannot control.</p><p>If you happen to have such an edge case, then do it in a loop:</p><p>for sync_condition_not_met() { sleep(small_amount_of_time) }</p><p>But often enough it's just a lazy way to wait until something has finished.
This turns out to be flaky and depends often on the execution speed of the machine.
Which is one reason why flaky unittests exist.</p><p>And yes, I'm very guilty of this myself.</p></div></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="25600" data-y="0" data-z="0"><h1 id="primitive-mutex">Primitive: Mutex</h1><p>A binary semaphore.</p><pre class="highlight code go"><span class="kd">var</span><span class="w"> </span><span class="nx">count</span><span class="w"> </span><span class="kt">int</span><span class="w">
</span><span class="kd">var</span><span class="w"> </span><span class="nx">mu</span><span class="w"> </span><span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span><span class="w">

</span><span class="kd">func</span><span class="w"> </span><span class="nx">inc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
    </span><span class="nx">count</span><span class="o">++</span><span class="w">
    </span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span><span class="w">

    </span><span class="c1">// or better:</span><span class="w">
    </span><span class="c1">// mu.Lock()</span><span class="w">
    </span><span class="c1">// defer mu.Unlock()</span><span class="w">
</span><span class="p">}</span></pre></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="27200" data-y="0" data-z="0"><h1 id="primitive-semaphor">Primitive: Semaphor</h1><pre class="highlight code go"><span class="c1">// Init the semaphore:</span><span class="w">
</span><span class="nx">semaphore</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nb">cap</span><span class="p">(</span><span class="nx">tokens</span><span class="p">);</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">semaphore</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">i</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="c1">// Limit number of jobs to 10 parallel jobs:</span><span class="w">
</span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">job</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">jobs</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="o">&lt;-</span><span class="nx">semaphore</span><span class="w">
    </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">job</span><span class="w"> </span><span class="nx">Job</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="c1">// ... do work here ...</span><span class="w">
        </span><span class="nx">semaphore</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="kc">true</span><span class="w">
    </span><span class="p">}(</span><span class="nx">job</span><span class="p">)</span><span class="w">
</span><span class="p">}</span></pre><div class="notes"><p>Very easy way to limit the number of go routines.
Basically a lightweight pool - good for one-time jobs.</p><p>Metaphor: A bouncer before a club.</p><p>It's corona times and he knows that only 10 people are allowed in the club
(sad times) He counts up when he let's somebody in and counts down when
someone leaves. If the club is full new visitors have to wait. Whem somebody
leaves then a new person may enter the "critical section" (club).</p></div></div><div class="step step-level-1" step="18" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="28800" data-y="0" data-z="0"><h1 id="primitive-barrier">Primitive: Barrier</h1><pre class="highlight code go"><span class="nx">wg</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span><span class="w">
</span><span class="k">for</span><span class="w"> </span><span class="nx">idx</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">idx</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="nx">idx</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w">
    </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="k">defer</span><span class="w"> </span><span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span><span class="w">
        </span><span class="nx">someJob</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
    </span><span class="p">}()</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="c1">// wait here for all jobs to finish:</span><span class="w">
</span><span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span></pre><div class="notes"><p>A barrier is basically an inverted semaphore: Instead of counting up
until you hit a limit (which means that too many jobs at the same time),
you count down until you reach zero (which means that all jobs are done)
All threads have to arrive a certain point before any can continue.</p><p>Alternative names: Wait Groups, Latch.</p></div></div><div class="step step-level-1" step="19" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="30400" data-y="0" data-z="0"><h1 id="primitive-cond-var">Primitive: Cond Var</h1><pre class="highlight code go"><span class="c1">// Init:</span><span class="w">
</span><span class="nx">m</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">{}</span><span class="w">
</span><span class="nx">c</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">sync</span><span class="p">.</span><span class="nx">NewCond</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span><span class="w">
</span><span class="c1">// ...</span><span class="w">
</span><span class="c1">// Sender:</span><span class="w">
</span><span class="nx">c</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w"> </span><span class="c1">// c.L == m</span><span class="w">
</span><span class="nx">newJobReceived</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span><span class="nx">c</span><span class="p">.</span><span class="nx">Broadcast</span><span class="p">()</span><span class="w"> </span><span class="c1">// or c.Signal() for a single go routine.</span><span class="w">
</span><span class="nx">c</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span><span class="w">
</span><span class="c1">// ...</span><span class="w">
</span><span class="c1">// Receiver:</span><span class="w">
</span><span class="nx">c</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
</span><span class="k">for</span><span class="w"> </span><span class="p">!</span><span class="nx">newJobReceived</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">c</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="c1">// Do something here.</span><span class="w">
</span><span class="nx">c</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span></pre><div class="notes"><p>Probably the most brainfuck-y of the primitives.</p><ul><li>Broadcast or notify a single thread.</li><li>Seldomly used in Go, but has their use cases.</li><li>Use case: waiting on a condition without busy polling
and where the use of channels would be awkward (channels
suck if you have to wake up several go routines, as messages
are consumed)</li></ul><p>When to use:</p><p>Channels are a good replacement if you just need to wake up
a single go routine. If you need to wake up many go routines
at the same time (Broadcast()) then condition variables are
way more efficient.</p><p>Context is a pattern that can be used in a similar way
(although rather exclusively for cancellation)</p></div></div><div class="step step-level-1" step="20" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="32000" data-y="0" data-z="0"><h1 id="primitive-channel">Primitive: Channel</h1><pre class="highlight code go"><span class="c1">// buffered channel with 10 items</span><span class="w">
</span><span class="nx">c1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="nx">c1</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// send</span><span class="w">
</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">c1</span><span class="p">)</span><span class="w"> </span><span class="c1">// recv</span><span class="w">

</span><span class="c1">// unbuffered channel:</span><span class="w">
</span><span class="nx">c2</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w">
</span><span class="nx">c2</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// send</span><span class="w">
</span><span class="c1">// deadlock!</span></pre><div class="notes"><p>Might be called prioq or something in other languages.
Basically a slice or linked list protected with a mutex (in case of a buffered channel)
or a single data field (in case of unbuffered channel)</p><p>Channels can be buffered or unbuffered:</p><ul><li>unbuffered: reads and writes block until the other end is ready.</li><li>buffer: blocks only when channel is full.</li></ul><p>Channels can be closed, which can be used as signal to stop.
A send to a closed channel panics.
A recv from a closed channel blocks forever.</p><p>A nil channel panics when something is send.
A nil channel block forever on receiving.</p><p>We will see channels later in action.</p></div></div><div class="step step-level-1" step="21" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="33600" data-y="0" data-z="0"><h1 id="primitive-select">Primitive: Select</h1><pre class="highlight code go"><span class="k">select</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">case</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">c1</span><span class="p">:</span><span class="w">
        </span><span class="c1">// executed when c1 has</span><span class="w">
        </span><span class="c1">// incoming data.</span><span class="w">
    </span><span class="k">case</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">c2</span><span class="p">:</span><span class="w">
        </span><span class="c1">// executed when c2 has</span><span class="w">
        </span><span class="c1">// incoming data.</span><span class="w">

    </span><span class="k">default</span><span class="p">:</span><span class="w">
        </span><span class="c1">// executed when nothing</span><span class="w">
        </span><span class="c1">// on both channels. If no</span><span class="w">
        </span><span class="c1">// 'default' given then</span><span class="w">
        </span><span class="c1">// select blocks.</span><span class="w">
</span><span class="p">}</span></pre><div class="notes"><p>select exists to be multiplex between several channels.</p><p>This feature does not exactly exist in most other languages.
Usually condition variables are used for this outside of Go
or something like await/asnyc in languages that have it.</p></div></div><div class="step step-level-1" step="22" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="35200" data-y="0" data-z="0"><h1 id="primitive-atomics">Primitive: Atomics</h1><pre class="highlight code go"><span class="kd">var</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="nx">atomic</span><span class="p">.</span><span class="nx">Uint64</span><span class="p">{}</span><span class="w">
</span><span class="nx">n</span><span class="p">.</span><span class="nx">Store</span><span class="p">(</span><span class="nx">val</span><span class="w"> </span><span class="kt">int64</span><span class="p">)</span><span class="w">
</span><span class="nx">n</span><span class="p">.</span><span class="nx">Load</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="nx">curr</span><span class="w"> </span><span class="kt">int64</span><span class="p">)</span><span class="w">
</span><span class="nx">n</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="nx">delta</span><span class="w"> </span><span class="kt">int64</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nx">new</span><span class="w"> </span><span class="kt">int64</span><span class="p">)</span><span class="w">
</span><span class="nx">n</span><span class="p">.</span><span class="nx">Swap</span><span class="p">(</span><span class="nx">val</span><span class="w"> </span><span class="kt">int64</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nx">old</span><span class="w"> </span><span class="kt">int64</span><span class="p">)</span><span class="w">
</span><span class="nx">n</span><span class="p">.</span><span class="nx">CompareAndSwap</span><span class="p">(</span><span class="nx">old</span><span class="p">,</span><span class="w"> </span><span class="nx">new</span><span class="w"> </span><span class="kt">int64</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nx">swapped</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span></pre><div class="notes"><p>Atomic: A thing that happens in one go. Either it fails completely and
leaves no trace or it work fully. Some operations can be executed on the
CPU atomically with guarantees of never being interrupted by another
thread, signal or ISR. Those are the above operations.</p><p>If you chain several atomic operations (e.g. Store+Load) they
are of course not atomic together!</p></div></div><div class="step step-level-1" step="23" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="36800" data-y="0" data-z="0"><h1 id="primitive-cas">Primitive: CAS</h1><pre class="highlight code go"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">cd</span><span class="w"> </span><span class="nx">countdown</span><span class="p">)</span><span class="w"> </span><span class="nx">Stop</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">cas</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">atomic</span><span class="p">.</span><span class="nx">CompareAndSwapInt32</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">cd</span><span class="p">.</span><span class="nx">isStopped</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="c1">// do not stop code twice if</span><span class="w">
        </span><span class="c1">// Stop() called more than once.</span><span class="w">
        </span><span class="k">return</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="c1">// Do actual stopping here.</span><span class="w">
</span><span class="p">}</span></pre><div class="notes"><p>The most exotic looking is CompareAndSwap and surprisingly it's the one that
is the most important one. It is roughly comparable to this code:</p><pre class="highlight code go"><span class="k">if</span><span class="w"> </span><span class="o">*</span><span class="nx">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">old</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="o">*</span><span class="nx">n</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">new</span><span class="w">
    </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="k">return</span><span class="w"> </span><span class="kc">false</span></pre><p>It's main use is implementing lockfree datastructures that notice
when a value was modified behind their back.</p><p>Additional use: Making sure that we don't stop twice.
(actual code example in the firmare's ui)</p></div></div><div class="step step-level-1" step="24" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="38400" data-y="0" data-z="0"><h1 id="primitive-lockfree-data-structures">Primitive: Lockfree data structures</h1><pre class="highlight code go"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">q</span><span class="w"> </span><span class="o">*</span><span class="nx">Queue</span><span class="p">)</span><span class="w"> </span><span class="nx">Pop</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="nx">Elem</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">for</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nx">p</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">q</span><span class="p">.</span><span class="nx">head</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="nx">p</span><span class="p">.</span><span class="nx">next</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="w">
        </span><span class="p">}</span><span class="w">

        </span><span class="c1">// Is `p` still the value that</span><span class="w">
        </span><span class="c1">// we expect it to be?</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="nx">cas</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">head</span><span class="p">,</span><span class="w"> </span><span class="nx">p</span><span class="p">,</span><span class="w"> </span><span class="nx">p</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="c1">// value was swapped!</span><span class="w">
            </span><span class="k">return</span><span class="w"> </span><span class="nx">p</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">elem</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span></pre><div class="notes"><p>Let's recall what a Pop() actually does:</p><ol><li>Fetch the head of the queue so we can return it.</li><li>Make the node after the old head the new head.</li></ol><p>(this assumes that the queue is based on a linked list)</p><p>Those are two operations and they are not atomic together.
If two threads call Pop() at the same time, we might have the issue
that one thread overwrites the results of the other.</p><p>In a traditional implementation we could use a mutex to protect this.
Newer CPUs (i.e. &gt;Year 2000) have CAS instructions, so we can implement
it without locks at all.</p></div></div><div class="step step-level-1" step="25" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="40000" data-y="0" data-z="0"><h1 id="contention-starvation">Contention &amp; Starvation</h1><ul><li><em>Contention:</em> Threads competing for a common resource. Causes non-zero waiting.
Can often not be avoided, just minimized.</li></ul><div class="line-block"><br></br></div><ul><li><em>Starvation:</em> Special case of <em>Contention</em> where one &#xBB;victim&#xAB; thread is blocked
from resource access more often that the other &#xBB;greedy&#xAB; threads. Pathological
behavior that should be fixed.</li></ul><div class="notes"><p>OS-level contention: done by the process/thread scheduler.
Threads are waiting on sleep, syscalls or waiting on a mutex.</p><p>Program level contention: waiting on locks, busy polling, atomics.</p><p>Lock-free data structures are so popular because they allow
a little cheat here: No syscalls involved, so they do not get
scheduled away. Mutex locks involve a call to futex() in some
cases, which is a syscall.</p><p>How to find out which threads content others or which threads get starved?
You gonna need to find out with tracing tools!</p><p>Contention: 100 threads that operate on a database that allows at most 10 parallel connections.
90 threads have to wait while 10 do work. Minimizing means to give the 90 threads some meaningful
work while they wait.</p><p>Real world example for starvation: Telephone Hotline where some people call
the hotline all the time automatically, while some normal people don't come through anymore.
With the example above: Maybe some threads use an outdated db library that makes it more
unlikely to get a connection from the connection pool.</p></div></div><div class="step step-level-1" step="26" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="41600" data-y="0" data-z="0"><h1 id="tracing">Tracing</h1><img src="images/tracer_goroutines.png" width="100%"></img><div class="notes"><p>Features of a tracer:</p><ul><li>View trace: Detailed overview of which core ran which goroutine at what time
and what blocked the process (like waiting for syscalls).</li><li>Goroutine analysis: Show stats per goroutine - see screenshot above.
This is a good overview how "parallel" the go routine actually is.
Does it do actual work or does it wait to be scheduled or locks?</li><li>Syscall blocking profile: Overview of contention through syscalls.
Check this if you suspect that your program is spending time waiting
for input/output.</li><li>Scheduler latency profiler: Scheduling goroutines comes with an overhead.
This overhead is noticeable and the higher it gets the less time there is
for actually useful stuff. Sometimes go routines just play "yield ping pong".</li></ul><p>Usage:</p><ul><li>Import "runtime/trace"</li><li>Open a file descriptor to where you'd like your trace output.</li><li>Do trace.Start(fd)/trace.Stop() around the desired code portion.</li><li>Run your program so that it produces a trace output in the file you specified.</li><li>Run go tool trace &lt;path&gt; to start the web ui.</li></ul><p>A bit more background: <a href="https://blog.gopheracademy.com/advent-2017/go-execution-tracer">https://blog.gopheracademy.com/advent-2017/go-execution-tracer</a></p></div></div><div class="step step-level-1" step="27" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="43200" data-y="0" data-z="0"><h1 id="patterns">Patterns</h1><p>Several primitives combined build a pattern.</p></div><div class="step step-level-1" step="28" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="44800" data-y="0" data-z="0"><h1 id="pattern-pool">Pattern: Pool</h1><p>Classical producer-consumer problem.</p><ol><li>Start a limited number of goroutines.</li><li>Pass each a shared channel.</li><li>Let each goroutine receive on the channel.</li><li>Producer sends jobs over the channel.</li><li>Tasks are distributed over the go routines.</li></ol><div class="notes"><p>Pools often use a queue (i.e. a channel or some other prioq). I.e. you can
produce more to some point than you consume. Can be a problem.</p></div></div><div class="step step-level-1" step="29" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="46400" data-y="0" data-z="0"><h1 id="pattern-pipeline">Pattern: Pipeline</h1><p>Several pools connected over channels.</p><pre class="highlight code go"><span class="c1">// DO NOT:</span><span class="w">
</span><span class="kd">func</span><span class="w"> </span><span class="nx">work</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">report</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">generateReport</span><span class="p">()</span><span class="w">
    </span><span class="nx">encoded</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">report</span><span class="p">.</span><span class="nx">Marshal</span><span class="p">()</span><span class="w">
    </span><span class="nx">compressed</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">compress</span><span class="p">(</span><span class="nx">encoded</span><span class="p">)</span><span class="w">
    </span><span class="nx">sendToNSA</span><span class="p">(</span><span class="nx">compressed</span><span class="p">)</span><span class="w">
</span><span class="p">}</span></pre><div class="notes"><p>Talk about the naive implementation where time of finish will
be influenced by a single long running job.</p></div></div><div class="step step-level-1" step="30" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="48000" data-y="0" data-z="0"><pre class="highlight code go"><span class="c1">// Instead:</span><span class="w">
</span><span class="nx">c1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="nx">type1</span><span class="p">)</span><span class="w">
</span><span class="nx">c2</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="nx">type2</span><span class="p">)</span><span class="w">
</span><span class="nx">c3</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="nx">type3</span><span class="p">)</span><span class="w">

</span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">for</span><span class="w"> </span><span class="nx">job</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">c1</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nx">c2</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">generateReport</span><span class="p">()</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}()</span><span class="w">
</span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">for</span><span class="w"> </span><span class="nx">report</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">c2</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nx">c3</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">report</span><span class="p">.</span><span class="nx">Marshal</span><span class="p">()</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}()</span><span class="w">

</span><span class="c1">// ...</span></pre><div class="notes"><p>This can also be easily combined with the pool pattern to start several go routines per pipeline step,
allowing us to easily balance out steps that take longer than others. Not shown here, take this as homework.</p></div></div><div class="step step-level-1" step="31" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="49600" data-y="0" data-z="0"><h1 id="pattern-parallel-iterator">Pattern: Parallel Iterator</h1><pre class="highlight code go"><span class="kd">func</span><span class="w"> </span><span class="nx">iter</span><span class="p">()</span><span class="w"> </span><span class="kd">chan</span><span class="w"> </span><span class="nx">Elem</span><span class="w"> </span><span class="p">{</span><span class="w">
     </span><span class="nx">ch</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="nx">Elem</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
     </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
         </span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w">
         </span><span class="k">for</span><span class="w"> </span><span class="p">{</span><span class="w">
             </span><span class="nx">ch</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">a</span><span class="w">
             </span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">b</span><span class="p">,</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">b</span><span class="w">
         </span><span class="p">}</span><span class="w">
     </span><span class="p">}()</span><span class="w">
     </span><span class="k">return</span><span class="w"> </span><span class="nx">ch</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="k">for</span><span class="w"> </span><span class="nx">elem</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">iter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">}</span></pre><div class="notes"><p>Problem: How to stop? Best to use context.Contex</p><p>Note: You should probably buffer a little here.</p></div></div><div class="step step-level-1" step="32" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="51200" data-y="0" data-z="0"><h1 id="problems">Problems</h1><p>What kind of problems do we need to solve with primitives and patterns?</p></div><div class="step step-level-1" step="33" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="52800" data-y="0" data-z="0"><h1 id="problem-race-conditions">Problem: Race conditions</h1><pre class="highlight code go"><span class="kd">var</span><span class="w"> </span><span class="nx">counter</span><span class="w"> </span><span class="kt">int</span><span class="w">
</span><span class="kd">func</span><span class="w"> </span><span class="nx">f</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">for</span><span class="p">(</span><span class="nx">idx</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">idx</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">10000</span><span class="p">;</span><span class="w"> </span><span class="nx">idx</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nx">counter</span><span class="o">++</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="c1">// ...</span><span class="w">
</span><span class="k">go</span><span class="w"> </span><span class="nx">f</span><span class="p">()</span><span class="w">
</span><span class="k">go</span><span class="w"> </span><span class="nx">f</span><span class="p">()</span></pre></div><div class="step step-level-1" step="34" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="54400" data-y="0" data-z="0"><h1 id="solution-race-conditions">Solution: Race conditions</h1><ul><li>Avoid shared state.</li><li>Prefer copy over references.</li><li>Limit scope where possible.</li><li>Use proper synchronisation.</li><li>Use a race detector. (<tt>helgrind</tt>, <tt>go test -race</tt>)</li><li>Write tests that are multithreaded.</li><li>Use Rust.</li></ul><div class="notes"><p>Shared state / Copy over reference:</p><p>Channels copy data on send. Copies do have issues when being accessed by
several threads. There is a small overhead of course, but it is much
smaller than false sharing. This also means though: Do not send pointers
over channels, as the pointer value itself is copied but of course not the
value it points to.</p><p>Scope:</p><p>Less scope is better. If a variable is only visible to a single thread
or goroutine, then it cannot have issues. Avoid global state anyways.</p><p>Proper synchronisation:</p><p>At some point you need to resort to sync primitives of course.
If you need to use too much of it, chances are you have an issue
in your architecture though.</p><p>Race detector / tests / rust:</p><p>Parallel code is complicated. Use whatever tools are available to
ensure correctness.</p></div></div><div class="step step-level-1" step="35" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="56000" data-y="0" data-z="0"><h1 id="tool-race-detector">Tool: Race detector</h1><pre class="highlight code bash"><span class="c1"># or for non-tests: go run -race main.go
</span>$<span class="w"> </span>go<span class="w"> </span><span class="nb">test</span><span class="w"> </span>-race<span class="w"> </span>./package<span class="w">
</span>WARNING:<span class="w"> </span>DATA<span class="w"> </span>RACE<span class="w">
</span>Read<span class="w"> </span>by<span class="w"> </span>goroutine<span class="w"> </span><span class="m">185</span>:<span class="w">
  </span>net.<span class="o">(</span>*pollServer<span class="o">)</span>.AddFD<span class="o">()</span><span class="w">
      </span>src/net/fd_unix.go:89<span class="w"> </span>+0x398<span class="w">
  </span>...<span class="w">

</span>Previous<span class="w"> </span>write<span class="w"> </span>by<span class="w"> </span>goroutine<span class="w"> </span><span class="m">184</span>:<span class="w">
  </span>net.setWriteDeadline<span class="o">()</span><span class="w">
      </span>src/net/sockopt_posix.go:135<span class="w"> </span>+0xdf<span class="w">
  </span>...</pre><div class="notes"><p>Herr Rittler likes this.</p><p>More info: <a href="https://go.dev/doc/articles/race_detector">https://go.dev/doc/articles/race_detector</a></p><p>Disadvantages:</p><ul><li>Slows down program a little. Sometimes races do not happen anymore
if -race is enabled.</li><li>It only sees race conditions that actually happen. If there's no test
for it, then you won't see a print.</li></ul><p>Still: You should probably enable it in your tests.</p></div></div><div class="step step-level-1" step="36" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="57600" data-y="0" data-z="0"><h1 id="problem-deadlocks">Problem: Deadlocks</h1><pre class="highlight code go"><span class="nx">ch</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w">

</span><span class="c1">// thread1:</span><span class="w">
</span><span class="nx">ch</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">42</span><span class="w">

</span><span class="c1">// thread2:</span><span class="w">
</span><span class="k">if</span><span class="w"> </span><span class="nx">someCondition</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">ch</span><span class="w">
</span><span class="p">}</span></pre><div class="notes"><p>Unbuffered channels are prone to deadlocks.
In this example we will have a deadlock in thread1
if thread2 does not go into the if block.</p><p>For this we probably should have used a buffered channel.</p></div></div><div class="step step-level-1" step="37" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="59200" data-y="0" data-z="0"><h1 id="problem-deadlock-2">Problem Deadlock #2</h1><pre class="highlight code go"><span class="kd">func</span><span class="w"> </span><span class="nx">foo</span><span class="p">()</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">bar</span><span class="p">();</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="k">return</span><span class="w"> </span><span class="nx">err</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span><span class="w">
    </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="w">
</span><span class="p">}</span></pre><div class="notes"><p>Absolute classic. Forgetting to unlock in one error case.</p><p>Luckily, in Go we have the defer statement, so we can unlock
the mutex in all cases.</p></div></div><div class="step step-level-1" step="38" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="60800" data-y="0" data-z="0"><h1 id="problem-deadlock-3">Problem Deadlock #3</h1><pre class="highlight code go"><span class="kd">func</span><span class="w"> </span><span class="nx">foo</span><span class="p">()</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">mu1</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
    </span><span class="nx">mu2</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
    </span><span class="c1">// ...</span><span class="w">
    </span><span class="k">defer</span><span class="w"> </span><span class="nx">mu1</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
    </span><span class="k">defer</span><span class="w"> </span><span class="nx">mu2</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="kd">func</span><span class="w"> </span><span class="nx">bar</span><span class="p">()</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">mu2</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
    </span><span class="nx">mu1</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
    </span><span class="c1">// ...</span><span class="w">
    </span><span class="k">defer</span><span class="w"> </span><span class="nx">mu2</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
    </span><span class="k">defer</span><span class="w"> </span><span class="nx">mu1</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
</span><span class="p">}</span></pre><div class="notes"><p>The lock hierarchy needs to be preserved. Otherwise
deadlocks might happen.</p></div></div><div class="step step-level-1" step="39" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="62400" data-y="0" data-z="0"><h1 id="solution-deadlocks">Solution: Deadlocks</h1><ul><li>Obtain a stacktrace if they happen. (<em>Ctrl-Backslash</em>)</li><li>Debugger (if deadlock is not timing sensitive)</li><li>Keep critical sections small.</li><li>Use defer for the <tt>Unlock</tt>.</li><li>Respect the lock hierarchy.</li><li>Double think if an unbuffered channel will work out.</li><li>Use unidirectional channels and <tt>select</tt> in Go.</li><li>Don't be <em>clever</em>.</li></ul><div class="notes"><p>Tip: In Go progamms you can press Ctrl+or send SIGABRT or SIGTERM
to the program to make it print a stack trace.
Or use a debugger.</p></div></div><div class="step step-level-1" step="40" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="64000" data-y="0" data-z="0"><h1 id="problem-livelock">Problem: Livelock</h1><p>Example:</p><ul><li>Two persons walking in opposite directions,
trying to pass each other in a tight corridor.</li><li>When both persons move at the same time left and right
then hallway is still blocked.</li><li>If infinitely done, then it's a livelock.</li></ul><div class="notes"><p>A system that does not make any progress for prolonged times.
Relatively seldom, but can happen.</p><p>Usual cause: Too primitive retry mechanism.</p></div></div><div class="step step-level-1" step="41" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="65600" data-y="0" data-z="0"><h1 id="solution-livelock">Solution: Livelock</h1><ul><li>Avoid circular dependencies.</li><li>Use an arbitrator.</li><li>Use exponential backoff.</li></ul><div class="notes"><ul><li>Arbitrator: In the metaphor above somebody that has an overview of the situation and tells one person to move.</li><li>Exponential backoff: Proper retry mechanism with random jitter between retries.</li></ul><p>Real life example: Two processes trying to execute an SQL transaction that depend on each other.
SQL server will stop the transaction and make them retry - if the retry mechanism is the same, then
it might take a long time to resolve the situation.</p></div></div><div class="step step-level-1" step="42" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="67200" data-y="0" data-z="0"><h1 id="problem-cancellation">Problem: Cancellation</h1><pre class="highlight code go"><span class="nx">resultCh</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w">
</span><span class="k">go</span><span class="w"> </span><span class="nx">longRunningJob</span><span class="p">(</span><span class="nx">resultCh</span><span class="p">)</span><span class="w">

</span><span class="c1">// Give job 5 seconds to complete:</span><span class="w">
</span><span class="k">select</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">case</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">resultCh</span><span class="p">:</span><span class="w">
        </span><span class="c1">// do something with `result`</span><span class="w">
    </span><span class="k">case</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nx">After</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">):</span><span class="w">
        </span><span class="nx">log</span><span class="p">.</span><span class="nx">Warnf</span><span class="p">(</span><span class="s">"Oh no! No result yet."</span><span class="p">)</span><span class="w">
        </span><span class="c1">// BUT: longRunningJob still running!</span><span class="w">
</span><span class="p">}</span></pre></div><div class="step step-level-1" step="43" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="68800" data-y="0" data-z="0"><h1 id="solution-context">Solution: Context</h1><pre class="highlight code go"><span class="c1">// Init:</span><span class="w">
</span><span class="nx">parentCtx</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">context</span><span class="p">.</span><span class="nx">Background</span><span class="p">()</span><span class="w">
</span><span class="nx">timeout</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="w">
</span><span class="nx">ctx</span><span class="p">,</span><span class="w"> </span><span class="nx">cancel</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">context</span><span class="p">.</span><span class="nx">WithTimeout</span><span class="p">(</span><span class="nx">parentCtx</span><span class="p">,</span><span class="w"> </span><span class="nx">timeout</span><span class="p">)</span><span class="w">

</span><span class="c1">// Cancellation:</span><span class="w">
</span><span class="nx">cancel</span><span class="p">()</span><span class="w">

</span><span class="c1">// Check for cancellation:</span><span class="w">
</span><span class="k">select</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">case</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">Done</span><span class="p">():</span><span class="w">
        </span><span class="k">return</span><span class="w"> </span><span class="nx">ctx</span><span class="p">.</span><span class="nx">Err</span><span class="p">()</span><span class="w">
    </span><span class="k">default</span><span class="p">:</span><span class="w">
        </span><span class="c1">// if not cancelled</span><span class="w">
        </span><span class="c1">// we land here.</span><span class="w">
</span><span class="p">}</span></pre><div class="notes"><p>Especially useful for HTTP request handlers.
In Go, each of them has a context that is cancelled
when the request is not needed anymore.</p></div></div><div class="step step-level-1" step="44" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="70400" data-y="0" data-z="0"><p>You almost made it! Just one slide left!</p><p class="small-text">And it's a very easy one and won't take a lot of time at all!</p></div><div class="step step-level-1" step="45" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="72000" data-y="0" data-z="0"><h1 id="brainfuck-time">Brainfuck time &#x1F9E0;</h1><img src="images/philosophers.png" width="60%"></img><div class="line-block"><br></br></div><ul><li>Philosophers toggle between &#xBB;thinking&#xAB; and &#xBB;eating&#xAB;.</li><li>The &#xBB;eating&#xAB; phase has a fixed length.</li><li>The &#xBB;thinking&#xAB; phase has a random length.</li><li>During &#xBB;eating&#xAB; he requires two forks.</li><li>If only one fork is available, they wait until a second one is available.</li></ul><p><strong>Goal:</strong> No philosopher should starve.</p><div class="notes"><p>Bonus: If you can name all philosophers pictured above.</p><p>Two problems that can occur:</p><ul><li>Deadlock: Every philosopher took the left fork. None can pick the right fork.</li><li>Starvation: A single philspopher might be unlucky and never get two forks.</li></ul><p>Solution:</p><ul><li>Simple: Use a single mutex as "waiter" to stop concurrency.</li><li>Hard &amp; correct: Use global mutex pluse "hungry" state with semaphor per philosopher.</li><li>Easier: Give philosophers invdividual rights and priorities.</li><li>Weird: philosopher talk to each other if they need a fork (i.e. channels)</li></ul></div></div><div class="step step-level-1" step="46" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="73600" data-y="0" data-z="0"><h1 id="fynn">Fynn!</h1><p>&#x1F3C1;</p></div></div><div id="slide-number" class="slide-number">
         1
      </div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/gotoSlide.js"></script><script type="text/javascript" src="js/hovercraft.js"></script><script type="text/javascript" src="hovercraft.js"></script><script type="text/javascript">
      document.getElementById("impress").addEventListener("impress:stepenter", update_slide_number, false);
    </script></body></html>