<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Performance: Concurrency</title><meta charset="UTF-8"></meta><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="hovercraft.css" media="screen,projection"></link><script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        showProcessingMessages: false,
        messageStyle: "none",
        TeX : { extensions : ['color.js'] }
      });
    </script></head><body class="impress-not-supported"><div id="impress-help"></div><div id="impress" data-transition-duration="1500"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="agenda">Agenda</h1><ul><li>Intro</li><li>Parallel primitives</li><li>Parallel problems</li><li>Parallel patterns</li><li>A hard problem</li></ul></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="parallel-programming">Parallel programming</h1><p>The art of distributing work so that we maximize
the number of used CPU cores with minimal overhead.</p><div class="notes"><p>There are two ways to be comfortable writing parallel code:</p><ul><li>Being very experienced and having made a lot of mistakes.</li><li>Being fearless and not be aware of the possible problems.</li></ul></div></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="concurrent-vs-parallel">Concurrent vs Parallel</h1><p>Please define it.</p><div class="notes"><p>Concurrent = execution might be interrupted at an time.
Parallel = several instructions get executed at the same time.</p></div></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><h1 id="what-are-processes">What are processes?</h1><ul><li>Processes are a lightweight way to schedule work over all available cpu cores.</li><li>Processes get started by <tt>fork()</tt> (except the first one...)</li><li>Processes focus on memory isolation - memory can only be shared via IPC (unix sockets, pipes, shared memory, ...)</li><li>Processes have their own ID (PID)</li></ul></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="what-are-threads">What are threads?</h1><ul><li>Threads are lightweight processes (huh?)</li><li>Threads get started by <tt>pthread_create()</tt></li><li>Threads share the heap of the process but have each their own stack</li><li>Threads have their own ID (TID)</li></ul><div class="notes"><p>Threads are scheduled like processes by the kernel. No real difference is made between
processes and threads in that regard.</p></div></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><h1 id="what-are-coroutines">What are coroutines?</h1><ul><li>Coroutines are lightweight threads (oh come on)</li><li>Coroutines are implemented completely in user space using a scheduler</li><li>Every detail depends on the individual programming languages' implementation</li><li>Goroutines are one example of a coroutine implementation. Fibers are another often used term.</li></ul><div class="notes"><p>Good example of software evolution. Old concepts are never cleaned up. Just new concepts
get added that enhance (in the best case) the old concepts. I call this toilet paper development:
If it stinks, put another layer over it.</p></div></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><h1 id="summary">Summary</h1><img src="images/time_sharing_threads.png"></img></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="11200" data-y="0" data-z="0"><h1 id="synchronization-primitives">Synchronization primitives</h1><p>Threads &amp; coroutines need to be in sync.</p><p>Big toolset of possible ways to do so.</p><div class="notes"><p>If you use processes you obviously need to synchronize too sometimes.
Potential ways can be to use filesystem locks or mlock() on shared memory.</p><p>If not used they can be a hell to debug. Debuggers won't work and prints
might change timings so deadlocks or race conditions might not always occur.</p></div></div><div class="step step-level-1" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12800" data-y="0" data-z="0"><h1 id="primitive-sleep">Primitive: Sleep</h1><p>Just kidding. Don't!</p></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="14400" data-y="0" data-z="0"><h1 id="primitive-semaphor">Primitive: Semaphor</h1><div class="notes"><p>A bouncer before a club.
It's corona times and he knows that only 10 people may be in the club (sad times)
He counts up when he let's somebody in and counts down when someone leaves.
If the club is full new visitors have to wait</p></div></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="16000" data-y="0" data-z="0"><h1 id="primitive-mutex">Primitive: Mutex</h1><p>A binary semaphore.</p></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="17600" data-y="0" data-z="0"><h1 id="primitive-barrier-latch-wait-group">Primitive: Barrier (latch, wait group)</h1><p>An inverted semaphore</p><div class="notes"><p>All threads have to arrive a certain point before any can continue.</p></div><p>Dining Philosopher's problem as intro to synchronisation -&gt; explain deadlock scenarios and how to debug them.</p></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="19200" data-y="0" data-z="0"><h1 id="primitive-condition-variable">Primitive: Condition variable</h1><pre class="highlight code">c.L.Lock()
for !condition() {
    c.Wait()
}
// condition changed, do something.
c.L.Unlock()</pre><pre class="highlight code">c.L.Lock()
changeCondition()
c.Broadcast() // or c.Signal() for a single go routine.
c.L.Unlock()</pre><div class="notes"><ul><li>Broadcast or notify a single thread.</li><li>Seldomly used in Go, but has their use cases.</li><li>Use case: waiting on a condition without busy polling
and where the use of channels would be awkward (channels
suck if you have to wake up several go routines, as messages
are consumed)</li></ul></div></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="20800" data-y="0" data-z="0"><h1 id="primitive-atomics">Primitive: Atomics</h1><ul><li>Store</li><li>Load</li><li>Increment</li><li>Swap</li><li>Compare-And-Swap</li></ul><div class="notes"><p>Several atomic operations are not atomic of course!</p></div></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="22400" data-y="0" data-z="0"><h1 id="primitive-channel">Primitive: Channel</h1><pre class="highlight code go"><span class="c1">// buffered channel with 10 items</span><span class="w">
</span><span class="nx">c</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="nx">c</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// send</span><span class="w">
</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">c</span><span class="p">)</span><span class="w"> </span><span class="c1">// recv</span></pre><div class="notes"><p>Might be called prioq or something in other languages.
Basically a slice or linked list protected with a mutex.</p><p>Channels can be buffered or unbuffered:</p><ul><li>unbuffered: reads and writes block until the other end is ready.</li><li>buffer: blocks only when channel is full.</li></ul><p>Channels can be closed, which can be used as signal to stop.
A send to a closed channel panics.
A recv from a closed channel blocks forever.</p><p>We will see channels later in action.</p></div></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="24000" data-y="0" data-z="0"><h1 id="pattern-pool">Pattern: Pool</h1><p>Classical producer-consumer problem.</p><ol><li>Start a limited number of goroutines.</li><li>Pass each a shared channel.</li><li>Let each goroutine receive on the channel.</li><li>Producer sends jobs over the channel.</li><li>Tasks are distributed over the go routines.</li></ol><div class="notes"><p>Pools often use a queue (i.e. a channel or some other prioq). I.e. you can
produce more to some point than you consume. Can be a problem.</p></div></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="25600" data-y="0" data-z="0"><h1 id="pattern-limiter">Pattern: Limiter</h1><pre class="highlight code go"><span class="nx">tokens</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nb">cap</span><span class="p">(</span><span class="nx">tokens</span><span class="p">);</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">tokens</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">i</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">job</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">jobs</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="o">&lt;-</span><span class="nx">tokens</span><span class="w">
    </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">job</span><span class="w"> </span><span class="nx">Job</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="c1">// ... do work ...</span><span class="w">
        </span><span class="nx">tokens</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="kc">true</span><span class="w">
    </span><span class="p">}(</span><span class="nx">job</span><span class="p">)</span><span class="w">
</span><span class="p">}</span></pre><div class="notes"><p>Very easy way to limit the number of go routines.
Basically a lightweight pool - good for one-time jobs.</p></div></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="27200" data-y="0" data-z="0"><h1 id="pattern-pipeline">Pattern: Pipeline</h1><p>Several pools connected over channels.</p><pre class="highlight code go"><span class="c1">// DO NOT:</span><span class="w">
</span><span class="kd">func</span><span class="w"> </span><span class="nx">work</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">report</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">generateReport</span><span class="p">()</span><span class="w">
    </span><span class="nx">encoded</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">report</span><span class="p">.</span><span class="nx">Marshal</span><span class="p">()</span><span class="w">
    </span><span class="nx">compressed</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">compress</span><span class="p">(</span><span class="nx">encoded</span><span class="p">)</span><span class="w">
    </span><span class="nx">sendToNSA</span><span class="p">(</span><span class="nx">compressed</span><span class="p">)</span><span class="w">
</span><span class="p">}</span></pre><div class="notes"><p>Talk about the naive implementation where time of finish will
be influenced by a single long running job.</p></div></div><div class="step step-level-1" step="18" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="28800" data-y="0" data-z="0"><h1 id="pattern-parallel-iterator">Pattern: Parallel Iterator</h1><pre class="highlight code go"><span class="kd">func</span><span class="w"> </span><span class="nx">iter</span><span class="p">()</span><span class="w"> </span><span class="kd">chan</span><span class="w"> </span><span class="nx">Elem</span><span class="w"> </span><span class="p">{</span><span class="w">
     </span><span class="nx">ch</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="nx">Elem</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
     </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
         </span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w">
         </span><span class="k">for</span><span class="w"> </span><span class="p">{</span><span class="w">
             </span><span class="nx">ch</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">a</span><span class="w">
             </span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">b</span><span class="p">,</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">b</span><span class="w">
         </span><span class="p">}</span><span class="w">
     </span><span class="p">}()</span><span class="w">
     </span><span class="k">return</span><span class="w"> </span><span class="nx">ch</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="k">for</span><span class="w"> </span><span class="nx">elem</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">iter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">}</span></pre><div class="notes"><p>Problem: How to stop? Best to use context.Contex</p><p>Note: You should probably buffer a little here.</p></div></div><div class="step step-level-1" step="19" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="30400" data-y="0" data-z="0"><h1 id="problem-shared-state">Problem: Shared state</h1><div class="notes"><p>Easiest solution: Communicate via copies, do not share memory.</p></div></div><div class="step step-level-1" step="20" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="32000" data-y="0" data-z="0"><h1 id="problem-race-conditions">Problem: Race conditions</h1><pre class="highlight code go"><span class="kd">var</span><span class="w"> </span><span class="nx">counter</span><span class="w"> </span><span class="kt">int</span><span class="w">
</span><span class="kd">func</span><span class="w"> </span><span class="nx">f</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">for</span><span class="p">(</span><span class="nx">idx</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">idx</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">10000</span><span class="p">;</span><span class="w"> </span><span class="nx">idx</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nx">counter</span><span class="o">++</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="c1">// ...</span><span class="w">
</span><span class="k">go</span><span class="w"> </span><span class="nx">f</span><span class="p">()</span><span class="w">
</span><span class="k">go</span><span class="w"> </span><span class="nx">f</span><span class="p">()</span></pre><p>---</p><h1 id="solution-race-conditions">Solution: Race conditions</h1><ul><li>Avoid shared state. Limit scope where possible.</li><li>Prefer copy over references.</li><li>Use proper synchronisation.</li><li>Use a race detector. (<tt>helgrind</tt>, <tt>go test -race</tt>)</li><li>Write tests that are multithreaded.</li><li>Use Rust.</li></ul></div><div class="step step-level-1" step="21" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="33600" data-y="0" data-z="0"><h1 id="problem-deadlocks">Problem: Deadlocks</h1><pre class="highlight code go"><span class="nx">ch</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w">

</span><span class="c1">// thread1:</span><span class="w">
</span><span class="nx">ch</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">42</span><span class="w">

</span><span class="c1">// thread2:</span><span class="w">
</span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">something</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">return</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="o">&lt;-</span><span class="nx">ch</span></pre></div><div class="step step-level-1" step="22" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="35200" data-y="0" data-z="0"><h1 id="problem-deadlock-2">Problem Deadlock #2</h1><pre class="highlight code go"><span class="kd">func</span><span class="w"> </span><span class="nx">foo</span><span class="p">()</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">bar</span><span class="p">();</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="k">return</span><span class="w"> </span><span class="nx">err</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span><span class="w">
    </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="w">
</span><span class="p">}</span></pre></div><div class="step step-level-1" step="23" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="36800" data-y="0" data-z="0"><h1 id="problem-deadlock-3">Problem Deadlock #3</h1><pre class="highlight code go"><span class="kd">func</span><span class="w"> </span><span class="nx">foo</span><span class="p">()</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">mu1</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
    </span><span class="nx">mu2</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
    </span><span class="c1">// ...</span><span class="w">
    </span><span class="k">defer</span><span class="w"> </span><span class="nx">mu1</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
    </span><span class="k">defer</span><span class="w"> </span><span class="nx">mu2</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="kd">func</span><span class="w"> </span><span class="nx">bar</span><span class="p">()</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">mu2</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
    </span><span class="nx">mu1</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
    </span><span class="c1">// ...</span><span class="w">
    </span><span class="k">defer</span><span class="w"> </span><span class="nx">mu2</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
    </span><span class="k">defer</span><span class="w"> </span><span class="nx">mu1</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
</span><span class="p">}</span></pre></div><div class="step step-level-1" step="24" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="38400" data-y="0" data-z="0"><h1 id="solution-deadlocks">Solution: Deadlocks</h1><ul><li>Obtain a stacktrace if they happen.</li><li>Debugger (if deadlock is not timing sensitive)</li><li>Keep critical sections small.</li><li>Use defer for the <tt>Unlock</tt>.</li><li>Respect the lock hierarchy.</li><li>Double think if an unbuffered channel will work out.</li><li>Use unidirectional channels and <tt>select</tt> in Go.</li><li>Don't be clever.</li></ul><div class="notes"><p>Deadlocks happen frequently when working with channels.</p><p>Tip: In Go progamms you can press Ctrl+or send SIGABRT or SIGTERM
to the program to make it print a stack trace.
Or use a debugger.</p><p>Don't be clever: There's a saying:</p><p>If you write the code as cleverly as possible, you are,
by definition, not smart enough to debug it.
--Brian Kernighan,</p><p>And our mind's horizon is never far away when doing parallel programming.</p></div></div><div class="step step-level-1" step="25" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="40000" data-y="0" data-z="0"><h1 id="problem-livelock">Problem: Livelock</h1><p>Example:</p><ul><li>Two persons walking in opposite directions,
trying to pass each other in a tight corridor.</li><li>When both persons move at the same time left and right
then hallway is still blocked.</li><li>If infinitely done, then it's a livelock.</li></ul><div class="notes"><p>A system that does not make any progress for prolonged times.
Relatively seldom, but can happen.</p><p>Usual cause: Too primitive retry mechanism.</p></div></div><div class="step step-level-1" step="26" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="41600" data-y="0" data-z="0"><h1 id="solution-livelock">Solution: Livelock</h1><ul><li>Avoid circular dependencies.</li><li>Use an arbitrator.</li><li>Use exponential backoff.</li></ul><div class="notes"><ul><li>Arbitrator: In the metaphor above somebody that has an overview of the situation and tells one person to move.</li><li>Exponential backoff: Proper retry mechanism with random jitter between retries.</li></ul><p>Real life example: Two processes trying to execute an SQL transaction that depend on each other.
SQL server will stop the transaction and make them retry - if the retry mechanism is the same, then
it might take a long time to resolve the situation.</p></div></div><div class="step step-level-1" step="27" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="43200" data-y="0" data-z="0"><h1 id="problem-resource-starvation">Problem: Resource starvation</h1><p>&#xBB;Greedy&#xAB; threads can block resources used by other threads.</p><div class="notes"><p>Resource: a database, some webserver, the CPU, the filesystem.</p><p>Can be caused by a deadlock, a livelock or any performance issues
or just duplicate work.</p><p>Typical in queuing systems:</p><ul><li>SlowConsumer</li><li>SlowProducer</li></ul></div></div><div class="step step-level-1" step="28" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="44800" data-y="0" data-z="0"><h1 id="solution-resource-starvation">Solution: Resource starvation</h1><ul><li>Make sure threads can not use resources exclusively.</li><li>Queuing: Allow a lot of buffering.</li><li>Benchmark: Are all resources used to full extent?</li></ul><div class="notes"><p>Buffering is necessary in queuing systems to account for slow producers / slow consumers.</p><p>Resource starvation is hard to fix in general and often goes unnoticed as it's often silent.
(i.e. system works, but is not as fast as it could have been)</p></div></div><div class="step step-level-1" step="29" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="46400" data-y="0" data-z="0"><h1 id="brainfuck-time">Brainfuck time</h1><img src="images/philosophers.png"></img><ul><li>Each philosopher changes state between "thinking" and "eating".</li><li>During "eating" he requires two forks (it's spaghetti)</li><li>The state changes happend randomly after some time.</li></ul><p>Goal: no philosopher should starve.</p><div class="notes"><p>Two problems that can occur:</p><ul><li>Deadlock: Every philosopher took the left fork. None can pick the right fork.</li><li>Starvation: A single philspopher might be unlucky and never get two forks.</li></ul><p>Solution:</p><ul><li>Simple: Use a single mutex as "waiter" to stop concurrency.</li><li>Hard &amp; correct: Use global mutex pluse "hungry" state with semaphor per philosopher.</li><li>Easier: Give philosophers invdividual rights and priorities.</li><li>Weird: philosopher talk to each other if they need a fork (i.e. channels)</li></ul></div></div></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/gotoSlide.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>