<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Performance: Concurrency</title><meta charset="UTF-8"></meta><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.io/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="hovercraft.css" media="screen,projection"></link><script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        showProcessingMessages: false,
        messageStyle: "none",
        TeX : { extensions : ['color.js'] }
      });
    </script></head><body class="impress-not-supported"><div id="impress-help"></div><div id="impress" data-transition-duration="950"><div class="step step-level-1" step="0" data-x="2500" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-y="0" data-z="0"><p class="chapter">Concurrency</p><p>Make things confusing fast &#x1F9F5;</p></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="5000" data-y="0" data-z="0"><h1 id="agenda">Agenda</h1><ul><li>Intro</li><li>Parallel primitives</li><li>Parallel problems</li><li>Parallel patterns</li><li>A hard problem</li></ul><div class="notes"><p>Examples in this workshop will be in Go. Reason: It's rather simple there. C
requires pthreads, which is a bit of an arcane library. Python has threads,
but they suck greatly (GIL). Other languages like Javascript are single threaded
by nature (well, there are web workers, but that's embarassing). Parallel
programming in bash would be fun, but you might not share my sense of humor.</p><p>We will not talk about GPU Programming, which is something that is also part of parallel
programming but it's seldom enough that you have to do that yourself.</p></div><img src="images/thread.jpg" width="40%"></img></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="7500" data-y="0" data-z="0"><h1 id="parallel-programming">Parallel programming</h1><p><em>&#xBB;The art of distributing work to maximize
the use of resources with minimal overhead.&#xAB;</em></p><p class="small-text">(while not shooting yourself in the knee by getting confused with the mindboggling behemoth you created)</p><div class="notes"><p>Today I won't give you tips on how to optimize the shit out of your parallel programs.
Parallel programs are a big and rather obvious speed-up by their own and I don't think
I have to prove that programs that uses several cores are faster than a single core, if
the task at hand can be splitted up in indepdendet subtasks. For parallel programs the
same principles as the CPU talk apply - especially true and false sharing. Correct use
of the cache is the most important thing here.
Today we will rather focus on how to achieve parallel programs in a safe way.</p><p>It really is an art, since there are no easy guidelines.</p><p>There are two ways to be comfortable writing parallel code:</p><ul><li>Being very experienced and having made a lot of mistakes.</li><li>Being fearless and not be aware of the possible problems.</li></ul></div></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="10000" data-y="0" data-z="0"><h1 id="there-s-always-a-xkcd">There's always a xkcd</h1><img src="images/xkcd_parallel.webp" width="100%"></img></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12500" data-y="0" data-z="0"><h1 id="rule-of-thumb">Rule of thumb &#x1F44D;</h1><div class="line-block"><br></br></div><p class="big-text"><strong>Don't.</strong> &#xB9;</p><p class="small-text">&#xB9; Unless you really, really need the performance and you proved this by benchmarks.</p><div class="notes"><p>Just to repeat: Concurrency hurts readability, will almost inevitably cause bugs
and eat your hamster. Proceed at your own risk.</p></div></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="15000" data-y="0" data-z="0"><p class="quote">If you write the code as cleverly as possible, you are,
by definition, not smart enough to debug it.</p><div class="line-block">- <strong>Brian Kernighan</strong><br></br></div><div class="notes"><p>Especially true for parallel programming as our brain is really not build
to think this way. So our mind's horizon is never far away when doing
parallel programming.</p></div></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="17500" data-y="0" data-z="0"><h1 id="concurrent-vs-parallel">Concurrent vs Parallel</h1><p>What's the difference again?</p><div class="notes"><p>Concurrent = concurrency is the composition of independently executing routines (execution might be interrupted at an time, how can me make it design code to allow that?)
Parallel = parallelism is the simultaneous execution of (possibly related) computations (several instructions get executed at the same time).</p><p>All parallel programs are also concurrent.</p><p>Why is the difference important?
See here: <a href="https://go.dev/blog/waza-talk">https://go.dev/blog/waza-talk</a></p></div></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="20000" data-y="0" data-z="0"><h1 id="what-are-processes">What are processes?</h1><ul><li>Processes are a lightweight way to schedule work over all available cpu cores.</li><li>Processes get started by <tt>fork()</tt> (except PID 1)</li><li>Processes focus on memory isolation - memory can only be shared via IPC (unix sockets, pipes, shared memory, network...)</li><li>Processes have their own ID (PID)</li></ul><div class="notes"><p>How can we achieve parallel execution? We have to use several cores
and an easy way to do that without any real extra work is to use several processes.
The OS scheduler will take care that the usage of cores gets maxed out.</p></div></div><div class="step step-level-1" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="22500" data-y="0" data-z="0"><h1 id="what-are-threads">What are threads?</h1><ul><li>Threads are lightweight processes (again?)</li><li>Threads get started by <tt>clone()</tt> (except first thread, which exists implicitly)</li><li>Threads share the heap of the process but have each their own stack</li><li>Threads have their own ID (TID)</li></ul><div class="notes"><p>Threads are scheduled like processes by the kernel. No real difference is made between
processes and threads in that regard. In fact, the kernel does not really handle them
much differently. The only real difference is that they share the same memory.</p></div></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="25000" data-y="0" data-z="0"><h1 id="what-are-coroutines">What are coroutines?</h1><ul><li>Coroutines are lightweight threads (oh come on now)</li><li>Coroutines are implemented completely in user space using a scheduler runtime (e.g. Go).</li><li>Every detail depends on the individual programming languages' implementation.</li><li>&#xBB;Goroutines&#xAB; are one example of a coroutine implementation. &#xBB;Fibers&#xAB; are another often used term.</li><li>Not a kernel concept, several coroutines can be executed by one tread and/or process.</li></ul><div class="notes"><p>Coroutines are actually a much different concept than the other two (processes and threads) as it's
not something that's powered by the operating system and differes wildly between implementation.
Coroutines can be seen as concurrent routines, i.e. routines that can be halted and continued at any given time
and can be composed to build parallel programs.</p><p>In case of Go, there is a scheduler that is started inside every program written in Go. It starts
a number of threads (see GOMAXPROCS) and schedules the set of go routines over the set of threads.</p></div></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="27500" data-y="0" data-z="0"><h1 id="cpu-perspective">CPU Perspective</h1><img src="images/time_sharing_threads.png"></img><div class="notes"><p>Note: Diagram is only for a single core. Several cores of course can do the
same. There are no coroutines in this picture since the CPU does not see
them. Technically it doesn't figure the difference between threads and
processes either.</p></div></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="30000" data-y="0" data-z="0"><h1 id="preemption">Preemption</h1><img src="images/preemption.png" width="100%"></img><div class="notes"><p>How can be actually manage to have a function that can be interrupted? Well,
we already know how: Context switches! And those happen all the time, even
if your program is not multithreaded.</p><p>Linux' scheduling is preemptive. This means that a high priority task
can be worked on by interrupting a task with lower priority.</p><p>Preemption points: The scheduler can interrupt a process at pretty much
any point in time. Normally this happens in any of those cases:</p><ul><li>Process used up their time share.</li><li>Process made a syscall. While execution happens in kernel, other
cores can work up on other tasks (especially for things like recv(),
or read() where the kernel also just waits on hardware)</li><li>When the process calls sched_yield() (or sleep())</li></ul></div></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="32500" data-y="0" data-z="0"><h1 id="no-magic-bullets">No magic bullets &#x1F52B;</h1><img src="images/epoll_vs_othersz.png" width="120%"></img><div class="notes"><p>Benchmark of a webserver handling dummy requests:</p><ul><li>forking: Spawn a new process per request.</li><li>preforking: Use a pool of worker process.</li><li>threaded: Spawn a new thread per request.</li><li>prethreaded: Use a pool of work threads.</li><li>poll: Single threaded using the poll() syscall.</li><li>epoll: Single threaded using the epoll() syscall.</li></ul><p>"Concurrency" is the number of requests per sec thrown
at the server, y axis is the actual handled requests.</p><p>Just throwing multithreading on a problem makes it complex,
but does not necessarily solve it.</p><p>Source: <a href="https://unixism.net/loti/async_intro.html">https://unixism.net/loti/async_intro.html</a></p><p>More details on the individual benchmarks:</p><p><a href="https://unixism.net/2019/04/linux-applications-performance-introduction">https://unixism.net/2019/04/linux-applications-performance-introduction</a></p><p>Most of the time, when used in the right dose, multithreaded programming
can easily speed up things. That's why this part of the workshop focuses more
on the safe use of parallel programming instead of squeezing every last bit
of performance out of parallel programming. Multiple threads are basically
a single optimization and deserve their own chapter therefore.</p><p>The contents in this part of the workshop are best applied with the understanding
of the CPU and Memory chapters.</p></div></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="35000" data-y="0" data-z="0"><h1 id="synchronization">Synchronization</h1><img src="images/thread_shared_state.png" width="100%"></img><div class="notes"><p>As with humans that work on a project in paralle, parallel jobs
need to synchronize to be useful. There is a big toolbox to do so.</p><p>If you use processes you obviously need to synchronize too sometimes.
Potential ways can be to use filesystem locks or mlock() on shared memory.</p><p>Failure to synchronize leads to race conditions and other bugs that are
really not fun to find. Debuggers won't work and prints might change
timings so deadlocks or race conditions might not always occur.</p></div></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="37500" data-y="0" data-z="0"><h1 id="critical-section">Critical Section</h1><pre class="highlight code go"><span class="kd">var</span><span class="w"> </span><span class="nx">count</span><span class="w"> </span><span class="kt">int</span><span class="w">

</span><span class="kd">func</span><span class="w"> </span><span class="nx">inc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">for</span><span class="w"> </span><span class="nx">idx</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">idx</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">100000</span><span class="p">;</span><span class="w"> </span><span class="nx">idx</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="c1">// critical section start</span><span class="w">
        </span><span class="nx">count</span><span class="o">++</span><span class="w">
        </span><span class="c1">// critical section end</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">go</span><span class="w"> </span><span class="nx">inc</span><span class="p">()</span><span class="w">
    </span><span class="k">go</span><span class="w"> </span><span class="nx">inc</span><span class="p">()</span><span class="w">
    </span><span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span><span class="w">
    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span><span class="w">
</span><span class="p">}</span></pre><div class="notes"><p>Keep critical sections as small as possible - for performance &amp; sanity.</p><p>Question for you:
* Why does this not happen if we reduce the 100000 to e.g. 1000?
* Why is there a sleep in main()?
* What synchronisation primitives do you know?</p><p>If you don't mention "sleep" then you're a little dishonest ;-)</p></div></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="40000" data-y="0" data-z="0"><h1 id="parallel-code-smell-1">Parallel code smell #1 &#x1F443;</h1><p class="quote">Never start a goroutine/thread/process without knowing how it will stop.</p><div class="line-block">- <strong>Dave Cheney</strong><br></br></div><div class="notes"><p>The previous slide had a race condition: The program might have exited before
the go routine do anything. In general: You should think about how your goroutines
are terminated.</p><p>Why? Similar to memory leaks, the phenomen of goroutine leaks exist. Most of them
come from place where people think "Ah, I don't need to close that go routine".</p><p>More background:
<a href="https://dave.cheney.net/2016/12/22/never-start-a-goroutine-without-knowing-how-it-will-stop">https://dave.cheney.net/2016/12/22/never-start-a-goroutine-without-knowing-how-it-will-stop</a></p></div></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="42500" data-y="0" data-z="0"><h1 id="primitive-sleep">Primitive: <tt>sleep()</tt></h1><p>Just kidding. <strong>Don't!</strong></p><p class="small-text">Okay, let's be honest. Sometimes you have no other way and we all did it.</p><div class="notes"><p>In all seriousness: there are some edge cases where sleep() is the only
way to reach some sort of sync state. Especially when we have to wait
on some external process that we cannot control.</p><p>If you happen to have such an edge case, then do it in a loop:</p><p>for sync_condition_not_met() { sleep(small_amount_of_time) }</p><p>But often enough it's just a lazy way to wait until something has finished.
This turns out to be flaky and depends often on the execution speed of the machine.
Which is one reason why flaky unittests exist.</p><p>And yes, I'm very guilty of this myself.</p></div></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="45000" data-y="0" data-z="0"><h1 id="primitive-mutex">Primitive: Mutex</h1><pre class="highlight code go"><span class="kd">var</span><span class="w"> </span><span class="nx">count</span><span class="w"> </span><span class="kt">int</span><span class="w">
</span><span class="kd">var</span><span class="w"> </span><span class="nx">mu</span><span class="w"> </span><span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span><span class="w">

</span><span class="kd">func</span><span class="w"> </span><span class="nx">inc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">for</span><span class="w"> </span><span class="nx">idx</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">idx</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">100000</span><span class="p">;</span><span class="w"> </span><span class="nx">idx</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
        </span><span class="nx">count</span><span class="o">++</span><span class="w">
        </span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="c1">// or better if a complete function is locked:</span><span class="w">
    </span><span class="c1">// mu.Lock()</span><span class="w">
    </span><span class="c1">// defer mu.Unlock()</span><span class="w">
</span><span class="p">}</span></pre><div class="notes"><p>Question: Would it still work if I would move the mutex into the function?</p><p>Variants:</p><ul><li>recursive mutex: can be locked several times, if unlocked the same time.</li><li>rw-mutex: Allows one writer, but many readers.</li></ul></div></div><div class="step step-level-1" step="18" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="47500" data-y="0" data-z="0"><h1 id="primitive-channel">Primitive: Channel</h1><pre class="highlight code go"><span class="c1">// buffered channel with 10 items</span><span class="w">
</span><span class="nx">c1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="nx">c1</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// send</span><span class="w">
</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">c1</span><span class="p">)</span><span class="w"> </span><span class="c1">// recv</span><span class="w">

</span><span class="c1">// unbuffered channel:</span><span class="w">
</span><span class="nx">c2</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w">

</span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">c2</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// send, locks until recv</span><span class="w">
</span><span class="p">}()</span><span class="w">
</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">c2</span><span class="p">)</span></pre><div class="notes"><p>Might be called prioq, fiber or something in other languages.
Basically a slice or linked list protected with a mutex (in case of a buffered channel)
or a single data field (in case of unbuffered channel)</p><p>Channels can be buffered or unbuffered:</p><ul><li>unbuffered: reads and writes block until the other end is ready.</li><li>buffer: blocks only when channel is full.</li></ul><p>Channels can be closed, which can be used as signal to stop.
A send to a closed channel panics.
A recv from a closed channel returns the zero value immediately.</p><p>A nil channel panics when something is send.
A nil channel block forever on receiving.</p><p>We will see channels later in action.</p></div></div><div class="step step-level-1" step="19" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="50000" data-y="0" data-z="0"><h1 id="channel-rules">Channel rules</h1><pre class="highlight code go"><span class="nx">c1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="c1">// unbuffered</span><span class="w">
</span><span class="nx">c2</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="c1">// buffered</span><span class="w">

</span><span class="c1">// A send on c1 would block until another go routine</span><span class="w">
</span><span class="c1">// will receive from it. On ch2 we can send 10 times</span><span class="w">
</span><span class="c1">// until the same happens.</span><span class="w">

</span><span class="c1">// channel are open or closed.</span><span class="w">
</span><span class="c1">// send on a closed channel panics</span><span class="w">
</span><span class="c1">// recv on a closed channel returns the zero value.</span><span class="w">
</span><span class="nb">close</span><span class="p">(</span><span class="nx">c1</span><span class="p">)</span><span class="w">
</span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">c1</span><span class="w"> </span><span class="c1">// ok would be false.</span></pre><div class="notes"><p>The good thing on channels: The values you send over it are (shallowly) copied, not referenced!
This means that the other thread can safely use it</p></div></div><div class="step step-level-1" step="20" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="52500" data-y="0" data-z="0"><h1 id="primitive-semaphor">Primitive: Semaphor</h1><pre class="highlight code go"><span class="c1">// Init the semaphore:</span><span class="w">
</span><span class="nx">semaphore</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nb">cap</span><span class="p">(</span><span class="nx">tokens</span><span class="p">);</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">semaphore</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">i</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="c1">// Limit number of jobs to 10 parallel jobs:</span><span class="w">
</span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">job</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">jobs</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="o">&lt;-</span><span class="nx">semaphore</span><span class="w">
    </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">job</span><span class="w"> </span><span class="nx">Job</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="c1">// ... do work here ...</span><span class="w">
        </span><span class="nx">semaphore</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="kc">true</span><span class="w">
    </span><span class="p">}(</span><span class="nx">job</span><span class="p">)</span><span class="w">
</span><span class="p">}</span></pre><div class="notes"><p>A semaphor is generalization of a mutex (which is also called binary semaphore)</p><p>Very easy way to limit the number of go routines.
Basically a lightweight pool - good for one-time jobs.</p><p>Metaphor: A bouncer before a club.</p><p>It's corona times and he knows that only 10 people are allowed in the club
(sad times) He counts up when he let's somebody in and counts down when
someone leaves. If the club is full new visitors have to wait. Whem somebody
leaves then a new person may enter the "critical section" (club).</p></div></div><div class="step step-level-1" step="21" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="55000" data-y="0" data-z="0"><h1 id="primitive-select">Primitive: Select</h1><pre class="highlight code go"><span class="k">select</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">case</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">c1</span><span class="p">:</span><span class="w">
        </span><span class="c1">// executed when c1 has</span><span class="w">
        </span><span class="c1">// incoming data.</span><span class="w">
    </span><span class="k">case</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">c2</span><span class="p">:</span><span class="w">
        </span><span class="c1">// executed when c2 has</span><span class="w">
        </span><span class="c1">// incoming data.</span><span class="w">
    </span><span class="k">default</span><span class="p">:</span><span class="w">
        </span><span class="c1">// executed when nothing</span><span class="w">
        </span><span class="c1">// on both channels. If no</span><span class="w">
        </span><span class="c1">// 'default' given then</span><span class="w">
        </span><span class="c1">// select blocks.</span><span class="w">
        </span><span class="c1">// Without default, we block.</span><span class="w">
</span><span class="p">}</span></pre><div class="notes"><p>select exists to be multiplex between several channels
and to figure out if we way send or receive from a channel.</p><p>This feature does not exactly exist in most other languages.
Usually condition variables are used for this outside of Go
or something like await/asnyc in languages that have it.</p></div></div><div class="step step-level-1" step="22" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="57500" data-y="0" data-z="0"><h1 id="primitive-barrier">Primitive: Barrier</h1><pre class="highlight code go"><span class="nx">wg</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span><span class="w">
</span><span class="k">for</span><span class="w"> </span><span class="nx">idx</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">idx</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="nx">idx</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w">
    </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="k">defer</span><span class="w"> </span><span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span><span class="w">
        </span><span class="nx">someJob</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
    </span><span class="p">}()</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="c1">// wait here for all jobs to finish:</span><span class="w">
</span><span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span></pre><div class="notes"><p>A barrier is basically an inverted semaphore: Instead of counting up
until you hit a limit (which means that too many jobs at the same time),
you count down until you reach zero (which means that all jobs are done)
All threads have to arrive a certain point before any can continue.</p><p>Alternative names: Wait Groups, Latch.</p><p>Question: Would it still be correct if we move the wg.Add(1) to the go routine?
No! There's a chance that wg.Wait() would not wait yet, because no go routine
did start yet.</p></div></div><div class="step step-level-1" step="23" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="60000" data-y="0" data-z="0"><h1 id="primitive-cond-var">Primitive: Cond Var</h1><pre class="highlight code go"><span class="c1">// Init:</span><span class="w">
</span><span class="nx">m</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">{}</span><span class="w">
</span><span class="nx">c</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">sync</span><span class="p">.</span><span class="nx">NewCond</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span><span class="w">

</span><span class="c1">// Sender:</span><span class="w">
</span><span class="nx">c</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w"> </span><span class="c1">// c.L == m</span><span class="w">
</span><span class="nx">condition</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span><span class="nx">c</span><span class="p">.</span><span class="nx">Broadcast</span><span class="p">()</span><span class="w"> </span><span class="c1">// or c.Signal() for a single go routine.</span><span class="w">
</span><span class="nx">c</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span><span class="w">

</span><span class="c1">// Receivers:</span><span class="w">
</span><span class="nx">c</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
</span><span class="k">for</span><span class="w"> </span><span class="p">!</span><span class="nx">condition</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">c</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="c1">// React on condition change here.</span><span class="w">
</span><span class="nx">c</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span></pre><div class="notes"><p>Probably the most brainfuck-y of the primitives.</p><ul><li>Broadcast or notify a single thread.</li><li>Seldomly used in Go, but has their use cases.</li><li>Use case: waiting on a condition without busy polling
and where the use of channels would be awkward (channels
suck if you have to wake up several go routines, as messages
are consumed)</li></ul><p>When to use:</p><p>Channels are a good replacement if you just need to wake up
a single go routine. If you need to wake up many go routines
at the same time (Broadcast()) then condition variables are
way more efficient.</p><p>Context is a pattern that can be used in a similar way
(although rather exclusively for cancellation)</p></div></div><div class="step step-level-1" step="24" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="62500" data-y="0" data-z="0"><h1 id="primitive-promises">Primitive: Promises</h1><pre class="highlight code go"><span class="kd">func</span><span class="w"> </span><span class="nx">fetchData</span><span class="p">(</span><span class="nx">url</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="kd">chan</span><span class="w"> </span><span class="nx">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">ch</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="nx">Result</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
    </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="c1">// use `url` somehow and do some potentially</span><span class="w">
        </span><span class="c1">// long running I/O work.</span><span class="w">
        </span><span class="nx">ch</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">Result</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="w">
    </span><span class="p">}()</span><span class="w">

    </span><span class="k">return</span><span class="w"> </span><span class="nx">ch</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">promise</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">longRunningTask</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
    </span><span class="c1">// ...do something else...</span><span class="w">
    </span><span class="c1">// await the result:</span><span class="w">
    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">promise</span><span class="p">)</span><span class="w">
</span><span class="p">}</span></pre><div class="notes"><p>Promises are a good way to make asynchronous code look like synchronous code.
A good example is fetching stuff via HTTP. While waiting for the response you can
potentially do something else.</p><p>You can also chain promises together. I.e. automatically do something
once the promise returns - by adding another go routine. This is called
promise chaining.</p><p>Other languages like Python/Javascript have first-class support
for async/await which kinda doing the same background. Go-routines
are however a more flexible concept and it's easy to write libraries
that emulate this behaviour (and others have done so)</p></div></div><div class="step step-level-1" step="25" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="65000" data-y="0" data-z="0"><h1 id="primitive-atomics">Primitive: Atomics</h1><pre class="highlight code go"><span class="kd">var</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="nx">atomic</span><span class="p">.</span><span class="nx">Uint64</span><span class="p">{}</span><span class="w">
</span><span class="nx">n</span><span class="p">.</span><span class="nx">Store</span><span class="p">(</span><span class="nx">val</span><span class="w"> </span><span class="kt">int64</span><span class="p">)</span><span class="w">
</span><span class="nx">n</span><span class="p">.</span><span class="nx">Load</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="nx">curr</span><span class="w"> </span><span class="kt">int64</span><span class="p">)</span><span class="w">
</span><span class="nx">n</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="nx">delta</span><span class="w"> </span><span class="kt">int64</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nx">new</span><span class="w"> </span><span class="kt">int64</span><span class="p">)</span><span class="w">
</span><span class="nx">n</span><span class="p">.</span><span class="nx">Swap</span><span class="p">(</span><span class="nx">val</span><span class="w"> </span><span class="kt">int64</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nx">old</span><span class="w"> </span><span class="kt">int64</span><span class="p">)</span><span class="w">
</span><span class="nx">n</span><span class="p">.</span><span class="nx">CompareAndSwap</span><span class="p">(</span><span class="nx">old</span><span class="p">,</span><span class="w"> </span><span class="nx">new</span><span class="w"> </span><span class="kt">int64</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nx">swapped</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span></pre><p class="example">Example: code/counter</p><div class="notes"><p>Atomic: A thing that happens in one go. Either it fails completely and
leaves no trace or it work fully. Some operations can be executed on the
CPU atomically with guarantees of never being interrupted by another
thread, signal or ISR. Those are the above operations.</p><p>This works by having special instructions to execute those that inform the CPU
that this operation has to be atomic.</p><p>If you chain several atomic operations (e.g. Store+Load) they
are of course not atomic together!</p></div></div><div class="step step-level-1" step="26" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="67500" data-y="0" data-z="0"><h1 id="primitive-cas">Primitive: CAS</h1><pre class="highlight code go"><span class="kd">type</span><span class="w"> </span><span class="nx">countdown</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">isStopped</span><span class="w"> </span><span class="kt">int32</span><span class="w"> </span><span class="p">}</span><span class="w">

</span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">cd</span><span class="w"> </span><span class="nx">countdown</span><span class="p">)</span><span class="w"> </span><span class="nx">Stop</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">cas</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">atomic</span><span class="p">.</span><span class="nx">CompareAndSwapInt32</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">cd</span><span class="p">.</span><span class="nx">isStopped</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="c1">// cd.isStopped is already 1!</span><span class="w">
        </span><span class="c1">// do not stop code twice if</span><span class="w">
        </span><span class="c1">// Stop() called more than once.</span><span class="w">
        </span><span class="k">return</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="c1">// Do actual stopping here.</span><span class="w">
</span><span class="p">}</span></pre><div class="notes"><p>The most exotic looking is CompareAndSwap and surprisingly it's the one that
is the most important one. It is roughly comparable to this code:</p><pre class="highlight code go"><span class="k">if</span><span class="w"> </span><span class="o">*</span><span class="nx">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">old</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="o">*</span><span class="nx">n</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">new</span><span class="w">
    </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="k">return</span><span class="w"> </span><span class="kc">false</span></pre><p>It's main use is implementing lockfree datastructures that notice
when a value was modified behind their back.</p><p>Additional use: Making sure that we don't stop twice.
(actual code example in the firmare's ui)</p></div></div><div class="step step-level-1" step="27" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="70000" data-y="0" data-z="0"><h1 id="primitive-lockfree-data-structures">Primitive: Lockfree data structures</h1><pre class="highlight code go"><span class="c1">// Pop has to do two things:</span><span class="w">
</span><span class="c1">// read the next elem and change the queue's head.</span><span class="w">
</span><span class="c1">// How to do this without locking?</span><span class="w">
</span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">q</span><span class="w"> </span><span class="o">*</span><span class="nx">Queue</span><span class="p">)</span><span class="w"> </span><span class="nx">Pop</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="nx">Elem</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">oldHead</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">q</span><span class="p">.</span><span class="nx">head</span><span class="w">
    </span><span class="k">for</span><span class="w"> </span><span class="p">!</span><span class="nx">cas</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">head</span><span class="p">,</span><span class="w"> </span><span class="nx">oldHead</span><span class="p">,</span><span class="w"> </span><span class="nx">oldHead</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="c1">// value was swapped - reload!</span><span class="w">
        </span><span class="nx">oldHead</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">q</span><span class="p">.</span><span class="nx">head</span><span class="w">
    </span><span class="p">}</span><span class="w">
    </span><span class="k">return</span><span class="w"> </span><span class="nx">oldHead</span><span class="w">
</span><span class="p">}</span></pre><div class="notes"><p>Let's recall what a Pop() actually does:</p><ol><li>Fetch the head of the queue so we can return it.</li><li>Make the node after the old head the new head.</li></ol><p>(this assumes that the queue is based on a linked list)</p><p>Those are two operations and they are not atomic together.
If two threads call Pop() at the same time, we might have the issue
that one thread overwrites the results of the other.</p><p>In a traditional implementation we could use a mutex to protect this.
Newer CPUs (i.e. &gt;Year 2000) have CAS instructions, so we can implement
it without locks at all.</p></div></div><div class="step step-level-1" step="28" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="72500" data-y="0" data-z="0"><h1 id="contention-starvation">Contention &amp; Starvation</h1><ul><li><em>Contention:</em> Threads competing for a common resource. Causes non-zero waiting.
Can often not be avoided, just minimized.</li></ul><div class="line-block"><br></br></div><ul><li><em>Starvation:</em> Special case of <em>Contention</em> where one &#xBB;victim&#xAB; thread is blocked
from resource access more often that the other &#xBB;greedy&#xAB; threads. Pathological
behavior that should be fixed.</li></ul><div class="notes"><p>OS-level contention: done by the process/thread scheduler.
Threads are waiting on sleep, syscalls or waiting on a mutex.</p><p>Program level contention: waiting on locks, busy polling, atomics.</p><p>Lock-free data structures are so popular because they allow
a little cheat here: No syscalls involved, so they do not get
scheduled away. Mutex locks involve a call to futex() in some
cases, which is a syscall.</p><p>How to find out which threads content others or which threads get starved?
You gonna need to find out with tracing tools!</p><p>Contention: 100 threads that operate on a database that allows at most 10 parallel connections.
90 threads have to wait while 10 do work. Minimizing means to give the 90 threads some meaningful
work while they wait.</p><p>Real world example for starvation: Telephone Hotline where some people call
the hotline all the time automatically, while some normal people don't come through anymore.
With the example above: Maybe some threads use an outdated db library that makes it more
unlikely to get a connection from the connection pool.</p></div></div><div class="step step-level-1" step="29" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="75000" data-y="0" data-z="0"><h1 id="patterns">Patterns</h1><p>Several primitives combined build a pattern.</p></div><div class="step step-level-1" step="30" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="77500" data-y="0" data-z="0"><h1 id="pattern-pool">Pattern: Pool</h1><p>Classical producer-consumer problem.</p><ol><li>Start a limited number of goroutines.</li><li>Pass each a shared channel.</li><li>Let each goroutine receive on the channel.</li><li>Producer sends jobs over the channel.</li><li>Tasks are distributed over the go routines.</li></ol><div class="notes"><p>Pools often use a queue (i.e. a channel or some other prioq). I.e. you can
produce more to some point than you consume. Can be a problem.</p></div><p class="example">Example: code/producer_consumer</p></div><div class="step step-level-1" step="31" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="80000" data-y="0" data-z="0"><h1 id="tracing">Tracing</h1><img src="images/tracer_goroutines.png" width="100%"></img><p class="example">Example: code/producer_consumer</p><div class="notes"><p>Features of a tracer:</p><ul><li>View trace: Detailed overview of which core ran which goroutine at what time
and what blocked the process (like waiting for syscalls).</li><li>Goroutine analysis: Show stats per goroutine - see screenshot above.
This is a good overview how "parallel" the go routine actually is.
Does it do actual work or does it wait to be scheduled or locks?</li><li>Syscall blocking profile: Overview of contention through syscalls.
Check this if you suspect that your program is spending time waiting
for input/output.</li><li>Scheduler latency profiler: Scheduling goroutines comes with an overhead.
This overhead is noticeable and the higher it gets the less time there is
for actually useful stuff. Sometimes go routines just play "yield ping pong".</li></ul><p>Usage:</p><ul><li>Import "runtime/trace"</li><li>Open a file descriptor to where you'd like your trace output.</li><li>Do trace.Start(fd)/trace.Stop() around the desired code portion.</li><li>Run your program so that it produces a trace output in the file you specified.</li><li>Run go tool trace &lt;path&gt; to start the web ui.</li></ul><p>A bit more background: <a href="https://blog.gopheracademy.com/advent-2017/go-execution-tracer">https://blog.gopheracademy.com/advent-2017/go-execution-tracer</a></p></div></div><div class="step step-level-1" step="32" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="82500" data-y="0" data-z="0"><h1 id="pattern-pipeline">Pattern: Pipeline</h1><p>Several pools connected over channels.</p><pre class="highlight code go"><span class="c1">// DO NOT:</span><span class="w">
</span><span class="kd">func</span><span class="w"> </span><span class="nx">work</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">report</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">generateReport</span><span class="p">()</span><span class="w">
    </span><span class="nx">encoded</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">report</span><span class="p">.</span><span class="nx">Marshal</span><span class="p">()</span><span class="w">
    </span><span class="nx">compressed</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">compress</span><span class="p">(</span><span class="nx">encoded</span><span class="p">)</span><span class="w">
    </span><span class="nx">sendToNSA</span><span class="p">(</span><span class="nx">compressed</span><span class="p">)</span><span class="w">
</span><span class="p">}</span></pre><div class="notes"><p>Talk about the naive implementation where time of finish will
be influenced by a single long running job.</p></div></div><div class="step step-level-1" step="33" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="85000" data-y="0" data-z="0"><pre class="highlight code go"><span class="c1">// Instead:</span><span class="w">
</span><span class="nx">c1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="nx">type1</span><span class="p">)</span><span class="w">
</span><span class="nx">c2</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="nx">type2</span><span class="p">)</span><span class="w">
</span><span class="nx">c3</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="nx">type3</span><span class="p">)</span><span class="w">

</span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">for</span><span class="w"> </span><span class="nx">job</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">c1</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nx">c2</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">generateReport</span><span class="p">()</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}()</span><span class="w">
</span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">for</span><span class="w"> </span><span class="nx">report</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">c2</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nx">c3</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">report</span><span class="p">.</span><span class="nx">Marshal</span><span class="p">()</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}()</span><span class="w">

</span><span class="c1">// ...</span></pre><div class="notes"><p>This can also be easily combined with the pool pattern to start several go routines per pipeline step,
allowing us to easily balance out steps that take longer than others. Not shown here, take this as homework.</p></div></div><div class="step step-level-1" step="34" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="87500" data-y="0" data-z="0"><h1 id="pattern-parallel-iterator">Pattern: Parallel Iterator</h1><pre class="highlight code go"><span class="kd">func</span><span class="w"> </span><span class="nx">fibonacci</span><span class="p">()</span><span class="w"> </span><span class="kd">chan</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w">
     </span><span class="nx">ch</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
     </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
         </span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w">
         </span><span class="k">for</span><span class="w"> </span><span class="p">{</span><span class="w">
             </span><span class="nx">ch</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">a</span><span class="w">
             </span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">b</span><span class="p">,</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">b</span><span class="w">
         </span><span class="p">}</span><span class="w">
     </span><span class="p">}()</span><span class="w">
     </span><span class="k">return</span><span class="w"> </span><span class="nx">ch</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="k">for</span><span class="w"> </span><span class="nx">elem</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">iter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">}</span></pre><div class="notes"><p>Problem: How to stop? Best to use context.Contex</p><p>Note: You should probably buffer a little here.</p></div></div><div class="step step-level-1" step="35" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="90000" data-y="0" data-z="0"><h1 id="problems">Problems</h1><p>What kind of problems do we need to solve with primitives and patterns?</p></div><div class="step step-level-1" step="36" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="92500" data-y="0" data-z="0"><h1 id="problem-race-conditions">Problem: Race conditions</h1><pre class="highlight code go"><span class="kd">var</span><span class="w"> </span><span class="nx">counter</span><span class="w"> </span><span class="kt">int</span><span class="w">
</span><span class="kd">func</span><span class="w"> </span><span class="nx">f</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">for</span><span class="p">(</span><span class="nx">idx</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">idx</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">10000</span><span class="p">;</span><span class="w"> </span><span class="nx">idx</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nx">counter</span><span class="o">++</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="c1">// ...</span><span class="w">
</span><span class="k">go</span><span class="w"> </span><span class="nx">f</span><span class="p">()</span><span class="w">
</span><span class="k">go</span><span class="w"> </span><span class="nx">f</span><span class="p">()</span></pre></div><div class="step step-level-1" step="37" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="95000" data-y="0" data-z="0"><h1 id="solution-race-conditions">Solution: Race conditions</h1><ul><li>Use synchronisation primitives.</li><li>Avoid shared state (no globals e.g.)</li><li>Prefer copies over references.</li><li>Use a race detector. (<tt>helgrind</tt>, <tt>go test -race</tt>)</li><li>Write tests that are multithreaded.</li><li>Use Rust. &#x1F61B;</li></ul><div class="notes"><p>Shared state / Copy over reference:</p><p>Channels copy data on send. Copies do have issues when being accessed by
several threads. There is a small overhead of course, but it is much
smaller than false sharing. This also means though: Do not send pointers
over channels, as the pointer value itself is copied but of course not the
value it points to.</p><p>Less scope is better. If a variable is only visible to a single thread
or goroutine, then it cannot have issues. Avoid global state anyways.</p><p>Proper synchronisation:</p><p>At some point you need to resort to sync primitives of course.
If you need to use too much of it, chances are you have an issue
in your architecture though.</p><p>Race detector / tests / rust:</p><p>Parallel code is complicated. Use whatever tools are available to
ensure correctness.</p></div></div><div class="step step-level-1" step="38" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="97500" data-y="0" data-z="0"><h1 id="tool-race-detector">Tool: Race detector</h1><pre class="highlight code bash"><span class="c1"># or for non-tests: go run -race main.go
</span>$<span class="w"> </span>go<span class="w"> </span><span class="nb">test</span><span class="w"> </span>-race<span class="w"> </span>./package<span class="w">
</span>WARNING:<span class="w"> </span>DATA<span class="w"> </span>RACE<span class="w">
</span>Read<span class="w"> </span>by<span class="w"> </span>goroutine<span class="w"> </span><span class="m">185</span>:<span class="w">
  </span>net.<span class="o">(</span>*pollServer<span class="o">)</span>.AddFD<span class="o">()</span><span class="w">
      </span>src/net/fd_unix.go:89<span class="w"> </span>+0x398<span class="w">
  </span>...<span class="w">

</span>Previous<span class="w"> </span>write<span class="w"> </span>by<span class="w"> </span>goroutine<span class="w"> </span><span class="m">184</span>:<span class="w">
  </span>net.setWriteDeadline<span class="o">()</span><span class="w">
      </span>src/net/sockopt_posix.go:135<span class="w"> </span>+0xdf<span class="w">
  </span>...</pre><div class="notes"><p>Herr Rittler likes this.</p><p>More info: <a href="https://go.dev/doc/articles/race_detector">https://go.dev/doc/articles/race_detector</a></p><p>Disadvantages:</p><ul><li>Slows down program a little. Sometimes races do not happen anymore
if -race is enabled.</li><li>It only sees race conditions that actually happen. If there's no test
for it, then you won't see a print.</li></ul><p>Still: You should probably enable it in your tests.</p></div></div><div class="step step-level-1" step="39" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="100000" data-y="0" data-z="0"><h1 id="problem-deadlock-1">Problem: Deadlock #1</h1><pre class="highlight code go"><span class="nx">ch</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w">

</span><span class="c1">// thread1:</span><span class="w">
</span><span class="nx">ch</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">42</span><span class="w">

</span><span class="c1">// thread2:</span><span class="w">
</span><span class="k">if</span><span class="w"> </span><span class="nx">someCondition</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">ch</span><span class="w">
</span><span class="p">}</span></pre><div class="notes"><p>Unbuffered channels are prone to deadlocks.
In this example we will have a deadlock in thread1
if thread2 does not go into the if block.</p><p>For this we probably should have used a buffered channel.</p></div></div><div class="step step-level-1" step="40" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="102500" data-y="0" data-z="0"><h1 id="problem-deadlock-2">Problem: Deadlock #2</h1><pre class="highlight code go"><span class="kd">func</span><span class="w"> </span><span class="nx">foo</span><span class="p">()</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">bar</span><span class="p">();</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="k">return</span><span class="w"> </span><span class="nx">err</span><span class="w">
    </span><span class="p">}</span><span class="w">

    </span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span><span class="w">
    </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="w">
</span><span class="p">}</span></pre><div class="notes"><p>Absolute classic. Forgetting to unlock in one error case.</p><p>Luckily, in Go we have the defer statement, so we can unlock
the mutex in all cases.</p></div></div><div class="step step-level-1" step="41" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="105000" data-y="0" data-z="0"><h1 id="problem-deadlock-3">Problem: Deadlock #3</h1><pre class="highlight code go"><span class="kd">func</span><span class="w"> </span><span class="nx">foo</span><span class="p">()</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">mu1</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
    </span><span class="nx">mu2</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
    </span><span class="c1">// ...</span><span class="w">
    </span><span class="k">defer</span><span class="w"> </span><span class="nx">mu1</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
    </span><span class="k">defer</span><span class="w"> </span><span class="nx">mu2</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="kd">func</span><span class="w"> </span><span class="nx">bar</span><span class="p">()</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">mu2</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
    </span><span class="nx">mu1</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
    </span><span class="c1">// ...</span><span class="w">
    </span><span class="k">defer</span><span class="w"> </span><span class="nx">mu2</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
    </span><span class="k">defer</span><span class="w"> </span><span class="nx">mu1</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">
</span><span class="p">}</span></pre><div class="notes"><p>The lock hierarchy needs to be preserved. Otherwise
deadlocks might happen.</p></div></div><div class="step step-level-1" step="42" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="107500" data-y="0" data-z="0"><h1 id="solution-deadlocks">Solution: Deadlocks</h1><ul><li>Obtain a stacktrace if they happen. (<em>Ctrl-Backslash</em>)</li><li>Debugger (if deadlock is not timing sensitive)</li><li>Keep critical sections small.</li><li>Use defer for the <tt>Unlock</tt>.</li><li>Respect the lock hierarchy.</li><li>Double think if an unbuffered channel will work out.</li><li>Use unidirectional channels and <tt>select</tt> in Go.</li><li>Don't be <em>clever</em>.</li></ul><div class="notes"><p>Tip: In Go progamms you can press Ctrl+\ or send SIGABRT or SIGTERM
to the program to make it print a stack trace.
Or use a debugger.</p></div><p class="example">Example: code/deadlock</p></div><div class="step step-level-1" step="43" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="110000" data-y="0" data-z="0"><h1 id="problem-livelock">Problem: Livelock</h1><p>Example:</p><ul><li>Two persons walking in opposite directions,
trying to pass each other in a tight corridor.</li><li>When both persons move at the same time left and right
then hallway is still blocked.</li><li>If infinitely done, then it's a livelock.</li></ul><div class="notes"><p>A system that does not make any progress for prolonged times.
Relatively seldom, but can happen.</p><p>Usual cause: Too primitive retry mechanism.</p></div></div><div class="step step-level-1" step="44" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="112500" data-y="0" data-z="0"><h1 id="solution-livelock">Solution: Livelock</h1><ul><li>Avoid circular dependencies.</li><li>Use an arbitrator.</li><li>Use exponential backoff.</li></ul><img src="images/backoff.png" width="70%"></img><div class="notes"><ul><li>Arbitrator: In the metaphor above somebody that has an overview of the situation and tells one person to move.</li><li>Exponential backoff: Proper retry mechanism with random jitter between retries.</li></ul><p>Real life example: Two processes trying to execute an SQL transaction that depend on each other.
SQL server will stop the transaction and make them retry - if the retry mechanism is the same, then
it might take a long time to resolve the situation.</p></div></div><div class="step step-level-1" step="45" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="115000" data-y="0" data-z="0"><h1 id="problem-cancellation">Problem: Cancellation</h1><pre class="highlight code go"><span class="nx">resultCh</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w">
</span><span class="k">go</span><span class="w"> </span><span class="nx">longRunningJob</span><span class="p">(</span><span class="nx">resultCh</span><span class="p">)</span><span class="w">

</span><span class="c1">// Give job 5 seconds to complete:</span><span class="w">
</span><span class="k">select</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">case</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">resultCh</span><span class="p">:</span><span class="w">
        </span><span class="c1">// do something with `result`</span><span class="w">
    </span><span class="k">case</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nx">After</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">):</span><span class="w">
        </span><span class="nx">log</span><span class="p">.</span><span class="nx">Warnf</span><span class="p">(</span><span class="s">"Oh no! No result yet."</span><span class="p">)</span><span class="w">
        </span><span class="c1">// BUT: longRunningJob still running!</span><span class="w">
</span><span class="p">}</span></pre></div><div class="step step-level-1" step="46" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="117500" data-y="0" data-z="0"><h1 id="solution-context">Solution: Context</h1><pre class="highlight code go"><span class="c1">// Init:</span><span class="w">
</span><span class="nx">parentCtx</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">context</span><span class="p">.</span><span class="nx">Background</span><span class="p">()</span><span class="w">
</span><span class="nx">timeout</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="w">
</span><span class="nx">ctx</span><span class="p">,</span><span class="w"> </span><span class="nx">cancel</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">context</span><span class="p">.</span><span class="nx">WithTimeout</span><span class="p">(</span><span class="nx">parentCtx</span><span class="p">,</span><span class="w"> </span><span class="nx">timeout</span><span class="p">)</span><span class="w">

</span><span class="c1">// Check for cancellation:</span><span class="w">
</span><span class="k">select</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">case</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">Done</span><span class="p">():</span><span class="w">
        </span><span class="k">return</span><span class="w"> </span><span class="nx">ctx</span><span class="p">.</span><span class="nx">Err</span><span class="p">()</span><span class="w">
    </span><span class="k">default</span><span class="p">:</span><span class="w">
        </span><span class="c1">// if not cancelled</span><span class="w">
        </span><span class="c1">// we land here.</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="c1">// Cancellation:</span><span class="w">
</span><span class="nx">cancel</span><span class="p">()</span></pre><div class="notes"><p>Especially useful for HTTP request handlers.
In Go, each of them has a context that is cancelled
when the request is not needed anymore.</p></div></div><div class="step step-level-1" step="47" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="120000" data-y="0" data-z="0"><h1 id="context-tree">Context Tree</h1><img src="images/context.avif" width="80%"></img></div><div class="step step-level-1" step="48" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="122500" data-y="0" data-z="0"><h1 id="takeaways">Takeaways</h1><ul><li>Benchmarks before committing your atrocities.</li><li>Always make sure to use proper synchronization.</li><li>Avoid having to synchronize by not sharing memory.</li><li>Don't use more go routines than you need.</li><li>Avoid false sharing.</li><li>Avoid contention &amp; starvation.</li><li>Write tests that use several go routines (-race).</li><li>Don't be clever.</li></ul></div><div class="step step-level-1" step="49" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="125000" data-y="0" data-z="0"><p>You almost made it! Just one slide left!</p><p class="small-text">And it's a very easy one and won't take a lot of time at all!</p></div><div class="step step-level-1" step="50" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="127500" data-y="0" data-z="0"><h1 id="brainfuck-time">Brainfuck time &#x1F9E0;</h1><img src="images/philosophers.png" width="50%"></img><div class="line-block"><br></br></div><ul><li>Philosophers toggle between &#xBB;thinking&#xAB; and &#xBB;eating&#xAB;.</li><li>The &#xBB;eating&#xAB; phase has a fixed length.</li><li>The &#xBB;thinking&#xAB; phase has a random length.</li><li>During &#xBB;eating&#xAB; he requires two forks.</li><li>If only one fork is available, they wait until a second one is available.</li></ul><p><strong>Goal:</strong> No philosopher should starve.</p><div class="notes"><p>We won't solve it today - possible solutions are on wikipedia:
<a href="https://en.wikipedia.org/wiki/Dining_philosophers_problem">https://en.wikipedia.org/wiki/Dining_philosophers_problem</a></p><p>But please don't look and better go and talk to me to see if you
figured out a valid solution!</p><p>Bonus: If you can name all philosophers pictured above:</p><ul><li>Descartes</li><li>Aristoteles (or Socrates?)</li><li>Konfuzius</li><li>?</li><li>?</li></ul><p>Two problems that can occur:</p><ul><li>Deadlock: Every philosopher took the left fork. None can pick the right fork.</li><li>Starvation: A single philspopher might be unlucky and never get two forks.</li></ul><p>Solution:</p><ul><li>Simple: Use a single mutex as "waiter" to stop concurrency.</li><li>Hard &amp; correct: Use global mutex pluse "hungry" state with semaphor per philosopher.</li><li>Easier: Give philosophers invdividual rights and priorities.</li><li>Weird: philosopher talk to each other if they need a fork (i.e. channels)</li></ul></div></div><div class="step step-level-1" step="51" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="130000" data-y="0" data-z="0"><h1 id="fynn">Fynn!</h1><div class="line-block"><br></br></div><p class="big-text">&#x1F3C1;</p><div class="line-block"><br></br></div><p class="next-link"><strong>Next:</strong> <a href="https://github.com/sahib/misc/tree/master/performance">Bookmark the GitHub repo!</a></p><div class="notes"><p>Final words:</p><p>Hope you had some fun and learned something. After all you endured 15 hours
of me trying to talk english. I'm aware that most of you did not do your
homework yet. I will and can not force you to do it, but in my opinion it is
<em>very</em> essential that you do some practice yourself. It's like in school
where the math teachins seemed obvious until you go and have a try yourself.
So please make me proud. ;-)</p><p>There is a calendar entry in December where you can show your approach, if you want. It's totally optional,
but if you want feedback by me or the others, then this is a good time for it.</p><p>Feedback time! How did you like the workshop? What could have been done better or differently?
What did you like, what didn't you like? You can also give me feedback via Slack or in the December meeting.</p></div></div></div><div id="slide-number" class="slide-number">
         1
      </div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/gotoSlide.js"></script><script type="text/javascript" src="js/hovercraft.js"></script><script type="text/javascript" src="hovercraft.js"></script><script type="text/javascript">
      document.getElementById("impress").addEventListener("impress:stepenter", update_slide_number, false);
    </script></body></html>