<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Performance: I/O</title><meta charset="UTF-8"></meta><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="hovercraft.css" media="screen,projection"></link><script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        showProcessingMessages: false,
        messageStyle: "none",
        TeX : { extensions : ['color.js'] }
      });
    </script></head><body class="impress-not-supported"><div id="impress-help"></div><div id="impress" data-transition-duration="1500"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="agenda">Agenda</h1><p>TODO: Agenda</p></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="latency-and-throughput">Latency and Throughput</h1><img src="images/waterpipe.png" width="50%"></img><ul><li>Latency = Time until the first drop of water arrives</li><li>Throughput = Current volume of water per time</li><li>Bandwidth = Maximum throughput</li></ul><p><strong>Examples:</strong></p><ul><li>SSDs: Low latency, high throughput.</li><li>HDDs: Medium latency, high throughput.</li><li>Network: Often high latency, any kind of throughput.</li><li>USB Stick over carrier pigeon: High latency, high throughput.</li></ul><div class="notes"><p>Last point was even standardized (jokingly): <a href="https://en.wikipedia.org/wiki/IP_over_Avian_Carriers">https://en.wikipedia.org/wiki/IP_over_Avian_Carriers</a></p></div></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="hardware-hdds">Hardware: HDDs</h1><img src="images/hdd.jpg" width="70%"></img><ul><li>Rotational, stacked disks.</li><li>Reading head needs to seek to the right position.</li><li>Mechanical system, bad at low/high temperature or moving systems.</li><li>Dying technology, but battled tested &amp; still widely used.</li></ul><div class="notes"><p>Big advantage: You could debug issues with too many seeks by audio!</p><p>Also: did you ever try to shake your old laptop with a hdd while reading?</p></div></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><h1 id="hardware-sdds">Hardware: SDDs</h1><img src="images/ssd.jpg" width="100%"></img><ul><li>Flash technology</li><li>No expensive seek necessary.</li><li>Limited number of write cycles.</li><li>Becoming cheaper and better every year.</li></ul><div class="notes"><p>Write software for SSDs. There were some crazy tricks like FIEMAP to make
applications re-order their reads in the order of how they are placed on disk.
(Huge speedup on HDD, small speedup on SSD)</p></div></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="hardware-write-amplification">Hardware: Write amplification</h1><img src="images/ssd_write_amplification.png" width="100%"></img><div class="notes"><p>Source: <a href="http://databasearchitects.blogspot.com/2021/06/what-every-programmer-should-know-about.html?m=1">http://databasearchitects.blogspot.com/2021/06/what-every-programmer-should-know-about.html?m=1</a></p><p>SSDs are divided into blocks (seveal MB), which are divided into pages (often 4K).
Pages cannot be erased, only blocks can be. Updates of a pages are written to new blocks.
If space runs out, old blocks with many stale pages are erased and can be re-used.
The number of physical writes is therefore higher than the number of logical writes.
The more space is used, the higher the write amplication factor though.</p><p>What we can do about it: Buy bigger SSDs than you need. Also avoid rewriting pages if possible.
Secret: SSD have some spare space to keep working they don't tell you about.</p><p>Also enable TRIM support if your OS did not yet, but nowadways always enabled.
This makes it possible for the OS to tell the SSD additional blocks that are not needed anymore.</p></div></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><h1 id="virtual-file-system">Virtual File System</h1><img src="images/vfs.webp" width="100%"></img><div class="notes"><p>Below device drivers: hardware controllers - beyond this talk.
They can also re-order writes and are mostly concerned with durability,
i.e. a SSD controller will try to distribute the blocks he used to make sure
they have a similar amount of write cycles.</p></div></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><h1 id="how-do-syscalls-work">How do syscalls work?</h1><p>Only method of userspace to talk to kernel.
How to call is ISA specific.</p><pre class="highlight code asm"><span class="nf">movl</span><span class="w"> </span><span class="no">$4</span><span class="p">,</span><span class="w"> </span><span class="nv">%eax</span><span class="w">   </span><span class="c1">; use the `write` system call (4)
</span><span class="nf">movl</span><span class="w"> </span><span class="no">$1</span><span class="p">,</span><span class="w"> </span><span class="nv">%ebx</span><span class="w">   </span><span class="c1">; write to stdout (1)
</span><span class="nf">movl</span><span class="w"> </span><span class="err">"</span><span class="no">Hello</span><span class="w"> </span><span class="no">World</span><span class="p">!</span><span class="err">\</span><span class="no">n</span><span class="err">"</span><span class="p">,</span><span class="w"> </span><span class="nv">%ecx</span><span class="w"> </span><span class="c1">; use string "Hello World"
</span><span class="nf">movl</span><span class="w"> </span><span class="no">$12</span><span class="p">,</span><span class="w"> </span><span class="nv">%edx</span><span class="w">  </span><span class="c1">; write 12 characters
</span><span class="nf">syscall</span><span class="w">         </span><span class="c1">; make system call via special instruction
</span><span class="w">                </span><span class="c1">; The return code is in the eax register.</span></pre><div class="notes"><p>The syscall instruction performs a context switch.</p><p>This means the current state of the process (i.e. the state of all registers
in the CPU) is saved away, so it can be restored later. Once done, the kernel
sets the register to its needs, does whatever is required to serve the system call.
When finished, the process state is restored and execution continues.</p><p>Context switches also happen when you're not calling any syscalls.
Simply when the scheduler decide this process is done with execution.</p></div></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="11200" data-y="0" data-z="0"><h1 id="typical-syscalls">Typical syscalls</h1><ul><li>IO: <tt>read</tt>, <tt>write</tt>, <tt>close</tt></li><li>Files: <tt>stat</tt>, <tt>chmod</tt>, <tt>mkdir</tt></li><li>Memory: <tt>sbrk</tt>, <tt>mmap</tt></li><li>Processes: <tt>fork</tt>, <tt>kill</tt>, <tt>wait</tt></li><li>Network: <tt>listen</tt>, <tt>connect</tt>, <tt>epoll</tt></li><li>Mysterious: <tt>ioctl</tt>, <tt>chroot</tt>, <tt>mount</tt></li></ul><div class="notes"><p>Luckily for us, glibc and Go provide us nice names and interfaces to make those system calls.
They usually provide thin wrappers that also do some basic error checking. Watch out: <tt>fread</tt>
is doing buffering in userspace!</p><p>Can anyone think of another syscall not in the list above? exit! chdir, mkdir, chmod, ...</p></div></div><div class="step step-level-1" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12800" data-y="0" data-z="0"><h1 id="syscalls-are-expensive">Syscalls are expensive</h1><pre class="highlight code bash">$ dd <span class="k">if</span><span class="o">=</span>/dev/urandom <span class="nv">of</span><span class="o">=</span>./big-file <span class="nv">bs</span><span class="o">=</span>1M <span class="nv">count</span><span class="o">=</span><span class="m">1024</span>
$ dd <span class="k">if</span><span class="o">=</span>big-file <span class="nv">of</span><span class="o">=</span>/dev/null <span class="nv">bs</span><span class="o">=</span>1b
<span class="m">4</span>,07281 s, <span class="m">264</span> MB/s
$ dd <span class="k">if</span><span class="o">=</span>big-file <span class="nv">of</span><span class="o">=</span>/dev/null <span class="nv">bs</span><span class="o">=</span>32b
<span class="m">0</span>,255229 s, <span class="m">4</span>,2 GB/s
$ dd <span class="k">if</span><span class="o">=</span>big-file <span class="nv">of</span><span class="o">=</span>/dev/null <span class="nv">bs</span><span class="o">=</span>1024b
<span class="m">0</span>,136717 s, <span class="m">7</span>,9 GB/s
$ dd <span class="k">if</span><span class="o">=</span>big-file <span class="nv">of</span><span class="o">=</span>/dev/null <span class="nv">bs</span><span class="o">=</span>32M
<span class="m">0</span>,206027 s, <span class="m">5</span>,2 GB/s</pre><p>Good buffer sizes: 1K - 32k</p><div class="notes"><p>Each syscall needs to store away the state of all registers in the CPU
and restore it after it finished. This is called "context switch".</p><p>Many syscalls vs a few big ones.</p><p>Try to reduce the number of syscalls,
but too big buffers hurt too.</p></div></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="14400" data-y="0" data-z="0"><h1 id="making-syscalls-visible">Making syscalls visible</h1><pre class="highlight code bash">$ strace ls /tmp</pre><div class="notes"><p>Insanely useful tool to debug hanging tools
or tools that crash without a proper error message.</p><p>Usually the last syscall they do give a hint.</p></div></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="16000" data-y="0" data-z="0"><h1 id="terminology-inode">Terminology: inode?</h1><p>The unique id of a file.
Several paths can have the same Inode.</p><pre class="highlight code bash">$ <span class="nb">echo</span> hello-world &gt; file
$ stat --format <span class="s1">'%i'</span> file
<span class="m">1883</span>
$ ln file hardlink
$ stat --format <span class="s1">'%i'</span> hardlink
<span class="m">1883</span></pre><div class="notes"><p>There's a theoretical maximum of inodes per filesystem.
Most filesystems prefer bigger files, since every file
lookup has to lookup the right one in a big set of inodes.</p></div></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="17600" data-y="0" data-z="0"><h1 id="page-cache">Page cache</h1><ul><li>All I/O access is cached using the page cache (dir + inode)</li><li>Free pages are used to store recently accessed file contents.</li><li>Performance impact can be huge.</li></ul></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="19200" data-y="0" data-z="0"><h1 id="clearing-the-cache">Clearing the cache</h1><p>For I/O benchmarks always clear all caches:</p><pre class="highlight code bash"><span class="c1"># 1: Clear page cache only.
# 2: Clear inodes/direntries cache.
# 3: Clear both.
</span>sync<span class="p">;</span> <span class="nb">echo</span> <span class="m">3</span> <span class="p">|</span> sudo tee /proc/sys/vm/drop_caches</pre><div class="notes"><p>Example: code/io_cache</p></div></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="20800" data-y="0" data-z="0"><h1 id="caveat-writes-are-buffered">Caveat: Writes are buffered!</h1><p>Make sure all file data is written to the hardware:</p><pre class="highlight code bash">sync</pre><pre class="highlight code c"><span class="n">fsync</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span></pre><div class="notes"><p>That's why we have the sync command before the drop_cache command.</p></div></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="22400" data-y="0" data-z="0"><h1 id="alternative-to-fsync">Alternative to <tt>fsync()</tt></h1><pre class="highlight code bash"><span class="c1"># Move is atomic!
</span>$ cp /src/bigfile /dst/bigfile.tmp
$ mv /dst/bigfile.tmp /dst/bigfile</pre><div class="notes"><p>This only works obviously if you're not constantly updating the file,
i.e. for files that are written just once.</p></div></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="24000" data-y="0" data-z="0"><h1 id="typical-read-i-o">Typical read I/O</h1><pre class="highlight code c"><span class="kt">char</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span><span class="w">
</span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">open</span><span class="p">(</span><span class="s">"/some/path"</span><span class="p">,</span><span class="w"> </span><span class="n">O_CREAT</span><span class="o">|</span><span class="n">O_RDONLY</span><span class="o">|</span><span class="n">O_TRUNC</span><span class="p">);</span><span class="w">
</span><span class="kt">size_t</span><span class="w"> </span><span class="n">bytes_read</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="k">while</span><span class="p">((</span><span class="n">bytes_read</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)))</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="cm">/* do something with buf[:bytes_read] */</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span></pre></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="25600" data-y="0" data-z="0"><h1 id="typical-write-i-o">Typical write I/O</h1><pre class="highlight code c"><span class="kt">char</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span><span class="w">
</span><span class="kt">size_t</span><span class="w"> </span><span class="n">bytes_in_buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">open</span><span class="p">(</span><span class="s">"/some/path"</span><span class="p">,</span><span class="w"> </span><span class="n">O_CREAT</span><span class="o">|</span><span class="n">O_WRONLY</span><span class="o">|</span><span class="n">O_TRUNC</span><span class="p">);</span><span class="w">
</span><span class="k">do</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="cm">/* fill buf somehow with data you'd like to write,
     * set bytes_in_buf accordingly.
     */</span><span class="w">
</span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">bytes_in_buf</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
</span><span class="n">fsync</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span><span class="w">
</span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span></pre><div class="notes"><p>There is a bug here:</p><p>write() returns the number of written bytes.
It might be less than bytes_in_buf and this is not counted as an error.
The write call might have simply been interrupted and we expect that it is
called another time with the remaining data.</p><p>Also: Does the application that the data is immediately for read()?
Answer: nope. You have to use fsync()</p><p>Also please note: There is some error handling missing here.</p></div></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="27200" data-y="0" data-z="0"><h1 id="fixed-write-version">Fixed write version</h1><pre class="highlight code c"><span class="cm">/* ... */</span><span class="w">
</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buf</span><span class="p">;</span><span class="w">
</span><span class="k">while</span><span class="p">(</span><span class="n">bytes_in_buf</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="kt">size_t</span><span class="w"> </span><span class="n">written</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">buf_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">bytes_in_buf</span><span class="p">);</span><span class="w">
   </span><span class="n">bytes_in_buf</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">written</span><span class="p">;</span><span class="w">
   </span><span class="n">buf_ptr</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">written</span><span class="p">;</span><span class="w">
   </span><span class="k">if</span><span class="p">(</span><span class="n">errno</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
       </span><span class="k">return</span><span class="p">;</span><span class="w">
   </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="cm">/* ... */</span></pre><div class="notes"><p>Many write utils actually handle this for you.
But io.Writer() behaves the same! Depending on the underlying
file type and system this might be rare but is a real thing.</p></div></div><div class="step step-level-1" step="18" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="28800" data-y="0" data-z="0"><h1 id="what-about-fread">What about <tt>fread()</tt>?</h1><p>A weird accident in history.</p><p><strong>Usecases:</strong></p><ul><li>You need to read byte by byte.</li><li>You need to unread some bytes frequently.</li><li>You need to read easily line by line.</li></ul><p>Otherwise: Do not use.</p><div class="notes"><p>Userspace buffered functions. No real advantage, but limiting and confusing API.
Has some extra features like printf-style formatting.</p><p>In Go the normal read/write is using the syscall directly,
bufio is roughly equivalent to f{read,write} etc.
fsync() is a sycasll, not part of that.</p></div></div><div class="step step-level-1" step="19" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="30400" data-y="0" data-z="0"><h1 id="detour-filesystems">Detour: Filesystems</h1><p>Performance depends a little on filesystem:</p><ul><li>ext2/3/4: good, stable &amp; fast choice.</li><li>fat8/16/32: simple, but legacy, do not use.</li><li>NTFS: slow and only for compatibility.</li><li>XFS: good with big files.</li><li>btrfs: feature-rich, can do CoW &amp; snapshots.</li><li>ZFS: highly scalable and very complex.</li><li>sshfs: remote access over FUSE</li></ul><div class="notes"><p>Actual implementation of read/write/etc. for a single
filesystem like FAT, ext4, btrfs. There are different ways
to layout and maintain data on disk, depending on your use case.</p><p>Syscalls all work the same, but some filesystems have
better performance regarding writes/reads/syncs or
are more targeted at large files or many files.</p><p>Most differences are admin related (i.e. integrity, backups,
snapshots etc.)</p></div></div><div class="step step-level-1" step="20" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="32000" data-y="0" data-z="0"><h1 id="detour-fragmentation">Detour: Fragmentation</h1><p>The problem that file content is distributed over many blocks.</p><pre class="highlight code">Windows sucks but this term stuck in our heads.

ext4 does not require fragmentation.</pre></div><div class="step step-level-1" step="21" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="33600" data-y="0" data-z="0"><h1 id="detour-fuse">Detour: FUSE</h1><img src="images/fuse.png" width="100%"></img></div><div class="step step-level-1" step="22" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="35200" data-y="0" data-z="0"><h1 id="a-note-on-seeking">A note on seeking</h1><ul><li>Rotational disks have only one reading head.</li><li>They re-order read requests</li><li>This can increase latency!</li><li>SSDs use</li></ul></div><div class="step step-level-1" step="23" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="36800" data-y="0" data-z="0"><h1 id="i-o-improving-performance">I/O improving performance</h1><ul><li>Avoid I/O.</li><li>Use a sane buffer size.</li><li>Use append only data for writing.</li><li>Batch writes as they evict caches.</li><li>Prefer few big files over many small files.</li><li>Avoid directories with high amount of files (<tt>git</tt>)</li><li>For modifying big files use mmap.</li><li>Buy faster hardware.</li></ul></div><div class="step step-level-1" step="24" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="38400" data-y="0" data-z="0"><h1 id="i-o-improving-performance-2">I/O improving performance #2</h1><ul><li>Use a different I/O scheduler (<tt>none</tt>).</li><li>Use a different filesystem (<tt>tmpfs</tt>)</li><li>Leverage the page cache and trust the OS</li><li>Use zero-copy techniques: <tt>sendfile</tt>, <tt>splice</tt></li><li>Not crazy: Use DMA if possible (hardware dependent)</li><li>Slightly crazy: fadvise() if you need prefetch</li><li>Maybe crazy: use O_DIRECT</li><li>Likely crazy: skip fsync()</li><li>Definitely crazy: FIEMAP</li></ul></div><div class="step step-level-1" step="25" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="40000" data-y="0" data-z="0"><h1 id="i-o-scheduler">I/O scheduler</h1><p>Re-orders read and write requests for performance.</p><ul><li><tt>none</tt>: Does no reordering.</li><li><tt>bfq</tt>: Complex, designed for desktops.</li><li><tt>mq-deadline</tt>, <tt>kyber</tt>: Simpler, good allround schedulers.</li></ul><div class="notes"><p>In the age of SSDs we can use dumber schedulers.
In the age of HDDs schedulers were vital.</p></div></div><div class="step step-level-1" step="26" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="41600" data-y="0" data-z="0"><h1 id="ionice"><tt>ionice</tt></h1><pre class="highlight code c"><span class="cp"># Default level is 4. Lower is higher.
</span><span class="n">$</span><span class="w"> </span><span class="n">ionice</span><span class="w"> </span><span class="o">-</span><span class="n">c</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">-</span><span class="n">n</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&lt;</span><span class="n">some</span><span class="o">-</span><span class="n">pid</span><span class="o">&gt;</span></pre><div class="notes"><p>Well, you can probably guess what it does.</p></div></div><div class="step step-level-1" step="27" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="43200" data-y="0" data-z="0"><h1 id="why-is-cp-faster">Why is cp faster?</h1><pre class="highlight code go"><span class="kn">package</span><span class="w"> </span><span class="nx">main</span><span class="w">

</span><span class="kn">import</span><span class="p">(</span><span class="w">
    </span><span class="s">"os"</span><span class="w">
    </span><span class="s">"io"</span><span class="w">
</span><span class="p">)</span><span class="w">

</span><span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nx">src</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="w">
    </span><span class="nx">dst</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">os</span><span class="p">.</span><span class="nx">Create</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="w">
    </span><span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span><span class="w"> </span><span class="nx">src</span><span class="p">)</span><span class="w">
</span><span class="p">}</span></pre><div class="notes"><p>cp is not faster because it copies data faster, but
because it avoids copies to user space by using specialized calls like:</p><ul><li>ioctl(5, BTRFS_IOC_CLONE or FICLONE, 4) = 0 (on btrfs)</li><li>copy_file_range() - performs in-kernel copy, sometimes even using DMA</li></ul><p>Find out using strace cp src dst.
If no trick is possible it falls back to normal buffered read/write.</p></div></div><div class="step step-level-1" step="28" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="44800" data-y="0" data-z="0"><h1 id="reduce-number-of-copies">Reduce number of copies</h1><ul><li>Do not copy buffers in your program too often</li><li>You can use <tt>readv</tt> to splice existing buffers to one.</li><li>Use hardlinks if possible</li><li>Use CoW reflinks if possible.</li><li><tt>sendfile()</tt> to copy files to Network.</li><li><tt>copy_file_range()</tt> to copy between files.</li></ul></div></div><div id="slide-number" class="slide-number">
         1
      </div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/gotoSlide.js"></script><script type="text/javascript" src="js/hovercraft.js"></script><script type="text/javascript">
      document.getElementById("impress").addEventListener("impress:stepenter", update_slide_number, false);
    </script></body></html>